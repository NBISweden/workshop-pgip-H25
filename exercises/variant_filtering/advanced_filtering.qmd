---
title: Advanced variant filtering
subtitle: Advanced variant filtering using mapping statistics
format:
  nbis-course-html:
      number-sections: false
author:
  - Per Unneberg
execute:
  cache: false
exercise:
  dir: variant-filtering
  venv: e-variant-filtering
---

<!-- markdownlint-disable MD041 -->

{{< include /exercises/_knitr.qmd >}}

{{< include /exercises/_rlibs.qmd >}}

```{bash }
#| label: init-dirs
#| echo: false
#| eval: true
mkdir -p mosdepth results bedtools
```

```{r }
#| label: r-init-vars
#| echo: false
#| eval: true
obj <- exercise_tools$variant_filtering$advanced_filtering
bioinfo_tools <- TRUE
```

<!-- markdownlint-enable MD041 -->

In this exercise we will look at ways of filtering variant data. We
will begin by applying filters to the variant file containing variant
sites only, followed by an approach that filters on sequencing depth
in a variant file containing both variant and invariant sites. The
latter methodology can then be generalized to generate depth-based
filters from BAM files.

{{< include /exercises/_subset.qmd >}}

::: {.callout-tip collapse=true}

## Learning objectives

- create per sample, per population, and total depth of coverage
  profiles
- apply filters to a VCF file

:::

{{< include /exercises/_tools.qmd >}}

## Advanced depth filtering on BAM files  {#sec-advanced-filtering}

::: {.callout-important}

This exercise is optional. It was created prior to the previous
filtering exercises and may contain overlapping explanations and
information. The procedure closely resembles that from the section on
genotype depth data above, but depth profiles are now calculated from
BAM files, which requires different tools.

:::

In this section, we will restrict our attention to coverage-based
filters, with the aim of generating *sequence masks* to denote regions
of a reference sequence that contain sufficient information across
individuals and populations. Furthermore, the masks will be applied in
the context of genetic diversity calculations, in which case specific
filters on polymorphic sites (e.g., *p*-value or minimum minor allele
frequency (MAF)) should **not** be applied (all sites contain
information).

Mapped reads provide information about how well a given genomic region
has been represented during sequencing, and this information is
usually summarized as the sequencing coverage. For any locus, this is
equivalent to the number of reads mapping to that locus.

Sequencing coverage is typically not uniformly distributed over the
reference. Reasons may vary but include uneven mapping coverage due to
repeat regions, low coverage due to mis-assemblies, or coverage biases
generated in the sequencing process. Importantly, both variable and
monomorphic sites must be treated identically in the filtering process
to eliminate biases between the two kinds of sites.

In this part, we will use `mosdepth` and `bedtools` to quickly
generate depth of coverage profiles of mapped data. `mosdepth` is an
ultra-fast command line tool for calculating coverage from a BAM file.
By default, it generates a summary of the global distribution, and
per-base coverage in `bed.gz` format. We will be using the per-base
coverage for filtering.

Alternatively, `mosdepth` can also output results in a highly
compressed format `d4`, which has been developed to handle the ever
increasing size of resequencing projects. Files in d4 format can be
processed with the [d4-tools](https://github.com/38/d4-format) tool
[@hou_BalancingEfficientAnalysis_2021]. For instance, `d4tools view`
will display the coverage in `bed` format. We mention this in passing
as it may be relevant when working with large genomes or sample sizes,
but given the size of our sample data, we will be using `bedtools`
from now on.

### Per sample coverage

We start by calculating per-sample coverages with `mosdepth`. For
downstream purposes, we need to save the size of the chromosomes we're
looking at, and for many applications, a fasta index file is
sufficient.

```{bash }
#| label: samtools-faidx
#| echo: true
#| eval: true
export REF=ref/M_aurantiacus_v1.fasta
samtools faidx ${REF}
```

```{r }
#| label: set-sample-envvars
#| echo: false
#| eval: true
Sys.setenv(REF="ref/M_aurantiacus_v1.fasta")
```

The syntax to generate coverage information for a BAM file is
`mosdepth <prefix> <input file>`. Here, we add the `-Q` option to
exclude reads with a mapping quality less than 20:

```{bash }
#| label: mosdepth-one-sample
#| echo: true
#| eval: true
mosdepth -Q 20 mosdepth/PUN-Y-INJ bam/PUN-Y-INJ.bam
```

The per-base coverage output file will be named
`PUN-Y-INJ.per-base.bed.gz` and can be viewed with `bgzip`:

```{bash }
#| label: bgzip-view-sample
#| echo: true
#| eval: true
bgzip -c -d mosdepth/PUN-Y-INJ.per-base.bed.gz | head -n 5
```

To get an idea of what the coverage looks like over the chromsome, we
will make use of two versatile programs for dealing with genomic
interval data and delimited text files. Both programs operate on
streams, enabling the construction of powerful piped commands at the
command line (see below).

The first is `bedtools`, which consists of a set of tools to perform
*genome arithmetic* on `bed`-like file formats. The
[`bed`](https://genome.ucsc.edu/FAQ/FAQformat.html#format1) format is
a tab-delimited format that at its simplest consists of the three
columns `chrom` (the chromosome name), `chromStart`, and `chromEnd`,
the start and end coordinates of a region.

The second is `csvtk`, a program that provides tools for dealing with
tab- or comma-separated text files. Avid `R` users will see that many
of the subcommands are similar to those in the [`tidyverse
dplyr`](https://dplyr.tidyverse.org/) package.

We can use these programs in a one-liner to generate a simple coverage
plot (@fig-plot-coverage)^[The one-liner combines the results of
several commands in a pipe stream. Also, [Bash
redirections](https://www.gnu.org/software/bash/manual/html_node/Redirections.html)
are used to gather the results from the output of `bedtools
makewindows` to `bedtools intersect`. The intersection commands
collects coverage data in 1kb windows that are then summarized by
`bedtools groupby`.]

```{bash }
#| label: bash-plot-coverage
#| echo: true
#| eval: true
bedtools intersect -a <(bedtools makewindows -g ${REF}.fai -w 1000) \
      -b mosdepth/PUN-Y-INJ.per-base.bed.gz -wa -wb | \
  bedtools groupby -i - -g 1,2,3 -c 7 -o mean | \
  csvtk plot -t line -x 2 -y 4 --point-size 0.01 --xlab Position \
      --ylab Coverage --width 9.0 --height 3.5 > results/fig-plot-coverage.png
```

::: {#fig-plot-coverage attr-output='.details summary="Output"'}

![](results/fig-plot-coverage.png)

Coverage for sample PUN-Y-INJ in 1kb windows. Experiment changing the
window size (`-w`) parameter to change smoothing.

:::

Apparently there are some high-coverage regions that could be
associated with, e.g., collapsed repeat regions in the assembly. Let's
compile coverage results for all samples, using bash string
manipulation to generate file prefix^[The `%` operator deletes the
shortest match of `$substring` from back of `$string`:
`${string%substring}`. See [Bash string
manipulation](https://tldp.org/LDP/abs/html/string-manipulation.html)
for more information.]

```{bash }
#| label: mosdepth-compile-coverage-data
#| echo: true
#| eval: true
# [A-Z] matches characters A-Z, * is a wildcard character that matches
# anything
for f in bam/[A-Z]*.bam; do
 # Extract the prefix by removing .sort.dup.recal.bam
 prefix=mosdepth/$(basename ${f%.bam})
 mosdepth -Q 20 $prefix $f
 # Print sample name
 echo -e -n "$prefix\t"
 # Get the summary line containing the total coverage
 cat $prefix.mosdepth.summary.txt | grep total
done > mosdepth/ALL.mosdepth.summary.txt
# View the file
cat mosdepth/ALL.mosdepth.summary.txt
```

We can calculate the total coverage by summing the values of the fifth
column with `csvtk` as follows:

```{bash }
#| label: mosdepth-compile-coverage-data-sum
#| echo: true
#| eval: false
csvtk summary -H -t mosdepth/ALL.mosdepth.summary.txt -f 5:sum
```

```{r }
#| label: mosdepth-compile-coverage-data-total
#| echo: false
#| eval: true
x <- read.table("mosdepth/ALL.mosdepth.summary.txt")
total_coverage <- sum(x$V5)

```

to get the total coverage `r total_coverage`, which gives a hint at
where the diploid coverage peak should be.

### Sample set coverages

In this section, we will summarize coverage information for different
sample sets, the motivation being that different filters may be
warranted depending on what samples are being analysed. For instance,
the coverage cutoffs for all samples will most likely be different
from those applied to the subpopulations. In practice this means
summing coverage tracks like those in @fig-plot-coverage for all
samples.

We can combine the coverage output from different samples with
`bedtools unionbedg`. We begin by generating a coverage file for all
samples, where the output columns will correspond to individual
samples. To save typing, we collect the sample names and generate
matching BED file names to pass as arguments to options `-names` and
`-i`, respectively. Also, we include positions with no coverage
(`-empty`) which requires the use of a genome file (option `-g`). The
BED output is piped to `bgzip` which compresses the output, before
finally indexing with `tabix`^[Instead of using the command
substitution, you could look into the sample info file and set the
sample names manually: `SAMPLES="PUN-Y-BCRD PUN-R-ELF PUN-Y-INJ
PUN-R-JMC PUN-R-LH PUN-Y-LO PUN-R-MT PUN-Y-PCT PUN-Y-POTR
PUN-R-UCSD"`].

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: bedtools-unionbedg-all
#| echo: true
#| eval: true
SAMPLES=$(csvtk grep -f Taxon -r -p "yellow" -r -p "red" sampleinfo.csv | csvtk cut -f SampleAlias | grep -v SampleAlias | tr "\n" " ")
BEDGZ=$(for sm in $SAMPLES; do echo -e -n "mosdepth/${sm}.per-base.bed.gz "; done)
bedtools unionbedg -header -names $SAMPLES -g ${REF}.fai -empty -i $BEDGZ | bgzip > bedtools/ALL.bg.gz
tabix -f -p bed -S 1 bedtools/ALL.bg.gz
```

::: {.callout-note collapse=true}

#### {{< fa brands linux >}} Command line magic

The code above works as follows. We first use `csvtk` to `grep`
(search) for the population names red and yellow in the `Taxon` column
in `sampleinfo.csv`, thereby filtering the output to lines where
`Taxon` matches the population names. Then, we cut out the interesting
column `SampleAlias` and remove the header (`grep -v SampleAlias`
matches anything but `SampleAlias`). Finally, `tr` translates newline
character `\n` to space. The output is stored in the `SAMPLES`
variable through the command substitution (`$()`) syntax.

We then iterate through the `$SAMPLES` to generate the input file
names with the `echo` command, storing the output in `$BEDGZ`. These
variables are passed on to `bedtools unionbedg` to generate a
[bedgraph file](https://genome.ucsc.edu/goldenPath/help/bedgraph.html)
combining all samples.

:::

<!-- markdownlint-enable MD013 -->

As mentioned previously, we also need to combine coverages per
populations yellow and red.

::: {.callout-exercise}

Using the previous command as a template, try to generate per
population coverage files.

::: {.callout-hint}

You only need to modify the code that generates `SAMPLES` by grepping
for each population separately (`csvtk grep -f Taxon -r -p red` and so
on), or setting them manually. Remember also to modify the output file
name (e.g., `red.bg.gz`).

:::

::: {.callout-answer}

<!-- markdownlint-disable MD013 -->

An example using a for loop is shown here. You could copy-paste the
code above and explicitly write out the population labels.

```{bash }
#| label: bedtools-unionbedg-per-population
#| echo: true
#| eval: true
for pop in red yellow; do
 SAMPLES=$(csvtk grep -f Taxon -r -p $pop sampleinfo.csv | csvtk cut -f SampleAlias | grep -v SampleAlias | tr "\n" " ")
 BEDGZ=$(for sm in $SAMPLES; do echo -e -n "mosdepth/${sm}.per-base.bed.gz "; done)
 bedtools unionbedg -header -names $SAMPLES -g ${REF}.fai -empty -i $BEDGZ | bgzip > bedtools/$pop.bg.gz
 tabix -f -p bed -S 1 bedtools/$pop.bg.gz
done
```

<!-- markdownlint-enable MD013 -->

:::

:::

### Total coverage

Since we eventually want to filter on total coverage, we sum per
sample coverages for each sample set with `awk`:

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: awk-sum-ALL-coverage
#| echo: true
#| eval: true
bgzip -c -d bedtools/ALL.bg.gz | \
 awk -v FS="\t" -v OFS="\t" 'NR > 1 {sum=0; for (i=4; i<=NF; i++) sum+=$i; print $1, $2, $3, sum}' | \
 bgzip > bedtools/ALL.sum.bed.gz
tabix -f -p bed bedtools/ALL.sum.bed.gz
```

Here we use `awk` to sum from columns 4 and up (`NF` is the number of
the last column).

<!-- markdownlint-enable MD013 -->

For illustration, we plot the total coverage:

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: total-coverage
#| echo: true
#| eval: true
#| fig-show: asis
#| fig-cap: Coverage for ALL samples in 1kb windows. Experiment changing the window size (`-w`) parameter to change smoothing.
bedtools intersect -a <(bedtools makewindows -g ${REF}.fai -w 1000) \
    -b bedtools/ALL.sum.bed.gz -wa -wb | \
  bedtools groupby -i - -g 1,2,3 -c 7 -o mean | \
  csvtk plot -t line -x 2 -y 4 --point-size 0.01 --xlab Position \
    --ylab Coverage --width 9.0 --height 3.5 > results/fig-plot-total-coverage.png
```

<!-- markdownlint-enable MD013 -->

::: {#fig-plot-total-coverage attr-output='.details summary="Output"'}

![](results/fig-plot-total-coverage.png)

Total coverage in 1kb windows.

:::

In order to define thresholds for subsequent filtering, we need to
know the total coverage distribution. Therefore, we plot the
proportion of the genome coverage versus depth of coverage (similar to
k-mer plots in sequence assembly projects). To do so we must summarize
our coverage file such that we count how many bases have a given
coverage. This can be achieved by noting that each row in the BED file
consists of the columns `CHROM`, `START`, `END`, and `COVERAGE`. We
can generate a histogram table by, for each value of `COVERAGE`,
summing the length of the regions (`END` - `START`).

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: compile-genome-coverage-for-plot
#| echo: true
#| eval: true
# Add column containing length of region (end - start)
csvtk mutate2 -t -H -w 0 -e '$3-$2' bedtools/ALL.sum.bed.gz | \
 # Sum the regions and *group* by the coverage (fourth column);
 # this gives the total number of bases with a given coverage
 csvtk summary -t -H -g 4 -f 5:sum -w 0 | \
 csvtk sort -t -k 1:n | \
 awk -v cumsum=0 'BEGIN {OFS=","; cumsum=0} {cumsum += $2; print $1,$2,cumsum}' > results/ALL.sum.bed.csv
```

<!-- markdownlint-enable MD013 -->

We plot the coverage distribution below, along with a plot of the
cumulative coverage.

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: total-depth-of-coverage-distribution
#| echo: true
#| eval: true
csvtk plot line -H results/ALL.sum.bed.csv -x 1 -y 2 --point-size 0.01 \
   --xlab "Depth of coverage (X)" --ylab "Genome coverage (bp)" \
   --width 9.0 --height 3.5 > results/fig-plot-total-coverage-distribution.png
csvtk plot line -H results/ALL.sum.bed.csv -x 1 -y 3 --point-size 0.01 \
   --xlab "Depth of coverage (X)" --ylab "Cumulative genome coverage (kbp)" \
   --width 9.0 --height 3.5 > results/fig-plot-total-coverage-distribution-cumulative.png
```

::: {#fig-plot-total-coverage-distribution attr-output='.details summary="Output"' layout-nrow=2}

![Genome coverage](results/fig-plot-total-coverage-distribution.png){#fig-plot-total-coverage-distribution-hist}

![Cumulative genome coverage](results/fig-plot-total-coverage-distribution-cumulative.png){#fig-plot-total-coverage-distribution-cumulative}

Genome coverage vs depth of coverage.
:::

<!-- markdownlint-enable MD013 -->

In @fig-plot-total-coverage-distribution a, a diploid peak is evident
at around coverage X=100; we zoom in on that region to get a better
view:

```{bash }
#| label: total-depth-of-coverage-zoom-in
#| echo: true
#| eval: false
csvtk plot line -H results/ALL.sum.bed.csv -x 1 -y 2 --point-size 0.01 \
    --xlab "Depth of coverage (X)" --ylab "Genome coverage (bp)" \
    --width 9.0 --height 3.5 --x-min 40 --x-max 140
```

```{bash }
#| label: plot-total-depth-of-coverage-zoom-in
#| echo: false
#| eval: true
csvtk plot line -H results/ALL.sum.bed.csv -x 1 -y 2 --point-size 0.01 \
   --xlab "Depth of coverage (X)" --ylab "Genome coverage (bp)" \
   --width 9.0 --height 3.5 --x-min 40 --x-max 140 > \
   results/fig-plot-total-coverage-distribution-hist-zoom-in.png
```

<!-- markdownlint-disable MD013 -->

::: {#fig-plot-total-coverage-distribution-zoom-in attr-output='.details summary="Output"'}

![Genome coverage](results/fig-plot-total-coverage-distribution-hist-zoom-in.png){#fig-plot-total-coverage-distribution-hist-zoom-in}

Genome coverage vs depth of coverage.

:::

<!-- markdownlint-enable MD013 -->

[@lou_BeginnerGuideLowcoverage_2021] point out that appropriate
thresholds depend on the data set, but as a general rule recommend a
minimum depth threshold at <0.8X average coverage, and a maximum depth
threshold at mean coverage plus one or two standard deviations. For
the sake of simplicity, you could here infer a cutoff simply by
manually inspecting @fig-plot-total-coverage-distribution-zoom-in;
here, we will use the range 50-110.

We then use these thresholds to generate a BED file containing regions
that are accessible, i.e., have sufficient coverage for downstream
analyses. We also calculate the number of bases that pass the
filtering criteria.

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: filter-all-bed-file-on-coverage
#| echo: true
#| eval: true
#| results: hide
csvtk filter -t -H bedtools/ALL.sum.bed.gz -f '4>50' | \
 csvtk filter -t -H -f '4<110' | \
 bgzip -c > bedtools/ALL.sum.depth.bed.gz
bedtools genomecov -i bedtools/ALL.sum.depth.bed.gz -g ${REF}.fai  | grep genome
```

<!-- markdownlint-enable MD013 -->

```{r }
#| label: r-compute-genome-coverage
#| echo: false
#| eval: true
x <- read.table("bedtools/ALL.sum.depth.bed.gz", header=FALSE)
cov <- format(sum(x$V3-x$V2) / 1e5 * 100, digits=3)
```

Consequently, `r cov`% of the genome is accessible by depth.

::: {.callout-exercise}

Generate coverage sums for the red and yellow sample sets, and from
these determine coverage thresholds and apply the thresholds to
generate BED files with accessible regions.

::: {.callout-answer}

We base the answer on the previous code.

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: awk-sum-sample-set-coverage
#| echo: true
#| eval: true
for pop in red yellow; do
 bgzip -c -d bedtools/$pop.bg.gz | \
  awk -v FS="\t" -v OFS="\t" 'NR > 1 {sum=0; for (i=4; i<=NF; i++) sum+=$i; print $1, $2, $3, sum}' | \
  bgzip > bedtools/$pop.sum.bed.gz
 tabix -f -p bed bedtools/$pop.sum.bed.gz
 csvtk mutate2 -t -H -w 0 -e '$3-$2' bedtools/$pop.sum.bed.gz | \
 csvtk summary -t -H -g 4 -f 5:sum -w 0 | \
 csvtk sort -t -k 1:n | \
 awk -v cumsum=0 'BEGIN {OFS=","; cumsum=0} {cumsum += $2; print $1,$2,cumsum}' > results/$pop.sum.bed.csv
done
```

<!-- markdownlint-enable MD013 -->

```{bash }
#| label: plot-sum-sample-set-coverage
#| echo: true
#| eval: true
for pop in red yellow; do
cat results/${pop}.sum.bed.csv | \
  csvtk plot line -x 1 -y 2 --point-size 0.01 \
    --xlab "Depth of coverage (X)" --ylab "Genome coverage (bp)" \
    --width 9.0 --height 3.5 --x-min 0 --x-max 100 > \
    results/fig-plot-total-coverage-distribution-hist-zoom-in-$pop.png
done
```

::: {#fig-plot-population-coverage-distribution attr-output='.details summary="Output"' layout-nrow=2}

![Zoomed in genome coverage, red](results/fig-plot-total-coverage-distribution-hist-zoom-in-red.png){#fig-plot-total-coverage-distribution-hist-zoom-in-red}

![Zoomed in genome coverage, yellow](results/fig-plot-total-coverage-distribution-hist-zoom-in-yellow.png){#fig-plot-total-coverage-distribution-hist-zoom-in-yellow}

Zoomed in coverage distribution for red and yellow ecotypes.
:::

Based on @fig-plot-population-coverage-distribution, we generate bed
files with depths passing cutoffs:

```{bash }
#| label: bedtools-genomecov-population-depth-files
#| echo: true
#| eval: true
# red filter: 20-60
csvtk filter -t -H bedtools/red.sum.bed.gz -f '4>20' | \
 csvtk filter -t -H -f '4<60' | \
 bgzip -c > bedtools/red.sum.depth.bed.gz
bedtools genomecov -i bedtools/red.sum.depth.bed.gz -g ${REF}.fai  | grep genome

# yellow filter: 20-55
csvtk filter -t -H bedtools/yellow.sum.bed.gz -f '4>20' | \
 csvtk filter -t -H -f '4<55' | \
 bgzip -c > bedtools/yellow.sum.depth.bed.gz
bedtools genomecov -i bedtools/yellow.sum.depth.bed.gz -g ${REF}.fai  | grep genome
```

:::

:::

Now we have combined total per sample coverage for ALL samples, and
for sample sets red and yellow. The upcoming task will be to generate
sequence masks from the total coverage and minimum number of
individuals with coverage greater than zero.

### Filter on minimum number of individuals

In addition to filtering on total coverage, we will also filter on the
minimum number of individuals with a minimum depth. This is to account
for cases where regions that pass the minimum coverage filter
originate from just a few samples with unusually high coverage. Here,
we will remove sites where more than 50% of individuals have zero
coverage.

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: awk-filter-50pct-ALL
#| echo: true
#| eval: true
bgzip -c -d bedtools/ALL.bg.gz | \
  awk -v FS="\t" 'BEGIN {OFS="\t"} NR > 1 {count=0; for (i=4; i<=NF; i++) {if ($i>0) count+=1}; if (count>=((NF-3)*0.5)) {print $1, $2, $3}}' | \
  bgzip > bedtools/ALL.ind.bed.gz
tabix -f -p bed bedtools/ALL.ind.bed.gz
```

::: {.callout-exercise}

Use `bedtools genomecov` to determine the proportion of bases that are
filtered out. Use `${REF}.fai` as the argument to the required option
`-g`.

::: {.callout-answer}

```{bash }
#| label: bedtools-genomecov-individual-filter
#| echo: true
#| eval: true
bedtools genomecov -i bedtools/ALL.ind.bed.gz -g ${REF}.fai
```

:::

:::

<!-- markdownlint-enable MD013 -->

::: {.callout-exercise}

Generate coverage sums for red and yellow sample sets.

::: {.callout-answer}

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: awk-filter-50pct-sample-set
#| echo: true
#| eval: true
for pop in red yellow; do
  bgzip -c -d bedtools/$pop.bed.gz | awk -v FS="\t" 'BEGIN {OFS="\t"} NR > 1 {count=0; for (i=4; i<=NF; i++) {if ($i>0) count+=1}; if (count>=((NF-3)*0.5)) {print $1, $2, $3}}' | bgzip > bedtools/$pop.ind.bed.gz
  tabix -f -p bed bedtools/$pop.ind.bed.gz
done
```

<!-- markdownlint-enable MD013 -->

:::

:::

### Sequence masks

Finally, as before, we can convert the BED output to sequence mask
files in FASTA format. Recall that we first have to make a template
genome mask file where all positions are masked:

```{bash }
#| label: bedtools-maskfasta-make-genome-mask-recall
#| echo: true
#| eval: true
awk 'BEGIN {OFS="\t"} {print $1, 0, $2}' ${REF}.fai > ${REF}.bed
bedtools maskfasta -fi ${REF} -mc 1 -fo ${REF}.mask.fa -bed ${REF}.bed
```

Then, for each sample set, we will use `bedtools intersect` to
intersect the BED files corresponding to the total sum coverage and
the filter on number of individuals. `bedtools intersect` makes it
easy to combine multiple BED files, so any other filters, or genomic
features such as exons, could be added to make a compound mask file.
The resulting BED files is used as input to `bedtools maskfasta`.

```{bash }
#| label: bedtools-intersect-all
#| echo: true
#| eval: true
bedtools intersect -a bedtools/ALL.sum.depth.bed.gz -b bedtools/ALL.ind.bed.gz \
   -g ${REF}.fai | bgzip > bedtools/ALL.unmask.bed.gz
tabix -f -p bed bedtools/ALL.unmask.bed.gz
bedtools maskfasta -fi ${REF}.mask.fa -mc 0 -fo ${REF}.unmask.fa \
   -bed bedtools/ALL.unmask.bed.gz
head -n 3 ${REF}.unmask.fa
```

We can once again convince ourselves that this has worked by counting
the number of unmasked positions:

```{bash }
#| label: count-unmasked-positions-again
#| echo: true
#| eval: true
# tr: -d deletes all characters not (-c, complement) in the character
# set '0'. wc: -m option counts characters
cat ${REF}.unmask.fa | tr -d -c '0' | wc -m
bedtools genomecov -i bedtools/ALL.unmask.bed.gz -g ${REF}.fai | grep genome
```

Note that 0 and 1 in the `bedtools genomecov` output refers to
coverage (i.e., absence/presence) and not unmask/mask as in the mask
FASTA file.

::: {.callout-exercise}

Create unmask files for red and yellow populations.

::: {.callout-answer}

```{bash }
#| label: bedtools-intersect-red-yellow
#| echo: true
#| eval: true
for pop in red yellow; do
 bedtools intersect -a bedtools/$pop.sum.depth.bed.gz -b bedtools/$pop.ind.bed.gz \
    -g ${REF}.fai | bgzip > bedtools/$pop.unmask.bed.gz
 tabix -f -p bed bedtools/$pop.unmask.bed.gz
 bedtools maskfasta -fi ${REF}.mask.fa -mc 0 -fo ${REF}.$pop.unmask.fa \
    -bed bedtools/$pop.unmask.bed.gz
done
```

:::

:::
