---
title: Primer on the coalescent and forward simulation
description: >-
  Introduction to the coalescent and forward simulation in general
author:
  - Per Unneberg
format:
  nbis-quarto-revealjs:
    toc: false
---

## Setup  {visibility="hidden" .unnumbered .unlisted}

{{< include ../_knitr.qmd >}}

{{< include ../_rlibs.qmd >}}

```{r libs}
#| echo: false
#| eval: true
#| cache: false
library(ape)
library(gganimate)
library(patchwork)
library(igraph)
library(ggraph)
library(tidygraph)
```

## Intended learning outcomes {.unnumbered .unlisted}

Introduction to the coalescent and simulation in msprime, with two
exercises on the coalescent and msprime. The students should be able
to:

- Describe need for simulations
- Demonstrate the coalescent step by step
- Detail some properties of coalescent trees
- Define the site-frequency spectrum
- Describe the coalescent with recombination
- Perform simple simulations in msprime

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-1
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 70%
#| fig-height: 12
#| fig-width: 8
#| fig-align: center
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
    geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

::: {.notes}

:::

### Recap

Model of a population describing **genealogies** under the following
assumptions

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

::: {.fragment}

**Forward** simulation

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-2
#| echo: false
#| eval: true
#| fig-cap: |
#|    Wright-Fisher model for 50 generations, 30 individuals.
#|    Black points represent individuals that pass on offspring
#|    to the next generation.
#| out-width: 70%
#| fig-width: 8
#| fig-height: 12
#| fig-align: center
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
    geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-graph
#| echo: false
#| eval: true
#| cache: false
#| fig-cap:
#|    Reproductive success in percent per generation.
#| out-width: 100%
#| fig-width: 12
#| fig-height: 8
#| fig-align: center
gdf <- g %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0, "b", "a")) %>%
  as.data.frame()
x <- tapply(gdf$allele, gdf$y, function(x) {
  sum(x == "b") / length(x)
})
xmean <- sprintf("%.1f%%", mean(x) * 100)
df <- data.frame(x = seq_along(x), y = x)
ggplot(subset(df, x < 50), aes(x = x, y = y * 100)) +
  geom_line(linewidth=1.2) +
  xlab("Generation") +
  ylab("Reproductive success (%)") +
  theme(text=element_text(size=36))
```

:::{}

Mean reproductive success = `r sprintf("%.1f%%", mean(x) * 100)`. Can
show for large populations P(no descendants)=$1 - e^{-1} \approx
0.632$

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## Forward and backward simulation {.smaller}

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

:::: {.columns}

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-forward
#| echo: false
#| eval: true
#| fig-cap:
#|    Forward simulation.
#| out-width: 60%
#| fig-width: 8
#| fig-height: 12
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-backward
#| echo: false
#| eval: true
#| fig-cap:
#|    Backward simulation.
#| out-width: 60%
#| fig-width: 8
#| fig-height: 12
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[2],
      xend = x1, yend = y_range[1]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

Simulated nodes are filled with black. Genealogy of interest is
highlighted in thick black lines.

::: {.notes}

Forward simulations: require that we keep track of the entire
population -> computationally challenging.

Backward simulations: require only tracking the sample -> quicker.
However, cannot model selection.

:::

## Why do we want simulations anyway?

::: {.incremental}

Null model
: Generate neutral null distributions to compare with observed data

Exploration
: Use to gain understanding and improve interpretation of mutational
  processes

Mathematical complexity
: No analytical solutions for linked selection and the like
  $\rightarrow$ must use simulations

Benchmarking
: Use to generate test data with known properties on which to test and
  evaluate new methods

Model training
: Generate training data for machine learning, e.g., Approximate
  Bayesian Computation (ABC) or Neural Networks (NNs)

:::

# The coalescent

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-1
#| echo: false
#| eval: true
#| out-width: 75%
#| fig-width: 8
#| fig-height: 12
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

NB: only the samples on the genealogy are needed, but the entire
population is shown as a means to compare with forward simulations.

:::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations
#| echo: false
#| eval: true
#| out-width: 75%
#| fig-width: 8
#| fig-height: 12
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label=mut),
                 angle_calc="along", label_size=18) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

<h4>Exercise</h4>

How many mutations are common to all samples? How many mutations does
sample 1 have? Sample 2?

Assuming the ancestral state is denoted `0` (prior to the *first*
generation) and the derived state `1`, what are the sequences of the
samples?

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations-1
#| echo: false
#| eval: true
#| out-width: 75%
#| fig-width: 8
#| fig-height: 12
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label=mut),
                 angle_calc="along", label_size=18) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

Answers to exercise: 2 mutations are common to all samples. Sample 1
has 3 mutations, sample 2 has 4.

(arbitrarily) ordering the sites from top to bottom (oldest mutation
comes first), the sequences are:

1: 11100
2: 11101
3: 11010

:::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-1
#| echo: false
#| eval: true
#| out-height: 600px
#| out-width: 500px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\useasboundingbox (t5l.south west) rectangle (t1r.north east);
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-2
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-3
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black,minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[selected, right of=3, node distance=60px] (4) {}
node[selected, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-4
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-5
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-6
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-7
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[selected] (1) {}
node[selected, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-8
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf] at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-9
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node[leaf] at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-10
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[leaf, above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-11
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-simulate-genealogy-end
#| echo: false
#| eval: true
#| fig-align: center
#| fig-cap:
#|   A simulated genealogy. The $T_i$ represent the
#|   waiting time when the state has $i$ chromosomes.
#| out-width: 60%
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::::

## Some properties of the tree {.smaller}

:::: {.columns}

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-genealogy-properties
#| echo: false
#| eval: true
#| fig-cap:
#|   A coalescent tree with numbered nodes. Nodes 1-5 correspond
#|   to the samples and are leaves. The internal nodes 6-8 (and the
#|   unlabelled root) are ancestral chromosomes (unsampled). The
#|   $T_i$ represent the waiting time when the state has $i$ chromosomes,
#|   whereas $\tau_i$ correspond to the branch length from node $i$
#|   to its parent.
#| fig-align: center
#| out-width: 60%
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          every label/.style={font=\sffamily\Large}
          ]

\draw
node[leaf, label={[yshift=-25pt]1}] (1) {1}
node[leaf, label={[yshift=-25pt]2}, right of=1, node distance=60px] (2) {2}
node[leaf, label={[yshift=-25pt]3}, right of=2, node distance=80px] (3) {3}
node[leaf, label={[yshift=-25pt]4}, right of=3, node distance=60px] (4) {4}
node[leaf, label={[yshift=-25pt]5}, right of=4, node distance=20px] (5) {5}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf, label={[xshift=10pt]7}] at ($(1) !.3! (root) $) (7) {7}
node[leaf, label={[xshift=10pt]8}] at ($(1) !.6! (root) $) (8) {8}
node[leaf, label={[xshift=10pt]6}] at ($(5) !.1! (root) $) (6) {6}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(1) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_1}$}
node at ($(2) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_2}$}
node at ($(3) !.45! (8) - (10pt, 0)$) () {$\mathbf{\tau_3}$}
node at ($(4) !.5! (6) - (10pt, 0)$) () {$\mathbf{\tau_4}$}
node at ($(5) !.5! (6) + (10pt, 0)$) () {$\mathbf{\tau_5}$}
node at ($(6) !.5! (root) + (10pt, 0)$) () {$\mathbf{\tau_6}$}
node at ($(7) !.5! (8) - (10pt, 0)$) () {$\mathbf{\tau_7}$}
node at ($(8) !.5! (root) - (10pt, 0)$) () {$\mathbf{\tau_8}$}
;


\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::: {.column width="50%"}

The **waiting time** for coalescence is **shorter** when there are
more lineages

Time to the **most recent common ancestor (MRCA)** (i.e., the tree
height) is the sum of the waiting times ($T_2 + T_3 + ...$)

On average, the time for coalescence when there are two remaining
lineages is **half** the tree height

:::

::::

::: {.notes}

Note that the parametrization is in 2N generations (continuous time
approximation); some use N, others 4N, and so on.

Expected waiting time: the first expression follows from the fact that
the waiting time, given $i$ chromosomes, is exponentially distributed
with parameter $\lambda=i(i-1)/2$. For an exponentially distributed
variable $X$, the expected value is simply $E(X)=1/\lambda$.

Other relations are most easily derived by studying the tree and
summing up relevant branches or time intervals.

Expected waiting time to coalesce when $i$ lineages: $E(T_i) =
\frac{2}{i(i-1)}$

Branch lengths can be derived from waiting times. For instance,
$\tau_1=\tau_2=T_5+T_4$ and $\tau_4=\tau_5=T_5$

Time to the **most recent common ancestor (MRCA)** is sum of wating
times: $T_{MRCA} = \sum_{i=2}^n T_i$

with expected value $E(T_{MRCA}) = \sum_{i=2}^nE(T_i) = 2\left(1 -
\frac{1}{n}\right)$

The expected **total tree height** is $E(T_{total}) = \sum_{i=2}^n
iE(T_i) = 2\sum_{i=2}^n\frac{1}{i-1}$

:::

## Coalescent simulations vary in topology and height {.smaller}

```{python }
#| label: msprime-simulations
#| cache: false
#| echo: true
#| eval: true
#| code-fold: true
import msprime
seeds = [12, 15, 34, 63, 30]
trees = [msprime.sim_ancestry(3, random_seed=x) for x in seeds]
```

:::{}

```{python }
#| label: fig-coalescent-trees-with-msprime
#| echo: false
#| eval: true
#| fig-format: svg
#| out-width: 70%
#| output: asis
#| fig-cap:
#|     Examples of coalescent simulations. Note the variation in tree
#|     topology and height.
#| fig-width: 12
#| fig-height: 8
kwargs = dict(x_axis=False, node_labels={},
              symbol_size=0, style=".edge {stroke-width: 2px}",
              root_svg_attributes={"id": "msprime-simulation"})
ymax = 500
tmrca = [ts.node(ts.first().root).time for ts in trees]
for i, ts in enumerate(trees):
    y = tmrca[i] / max(tmrca) * ymax
    print(ts.draw_svg(size=(200, y), **kwargs))
```

:::

Examples of coalescent simulations. Note the variation in tree
topology and height.

## Diminishing returns of adding more samples

:::{}

```{r }
#| label: fig-coalescent-diminishing-returns
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 6
#| fig-align: center
#| out-width: 80%
#| fig-cap:
#|     Dependence of time to most recent common ancestor ($T_{MRCA}$)
#|     and total branch length of tree on the
#|     sample size n. Already at low values of n the value of
#|     $T_{MRCA}$ is close to its asymptotic value, which has
#|     practical consequences for the measurement of DNA variation;
#|     adding more samples mainly adds tips to the trees and does
#|     not provide access to deep time.
#|     Adapted from @wakeley_CoalescentTheoryIntroduction_2008,
#|     Fig. 3.3.
n <- 20
t_total <- function(n) {2*sum(1/(seq(2,n)-1))}
t_mrca <- function(n) {2*(1 - 1/n)}

data <- data.frame(y=c(c(0, unlist(lapply(2:n, t_total))),
                       c(0, unlist(lapply(2:n, t_mrca)))),
                       x=c(1:n, 1:n),
                       stat=c(rep("E[T_total]", n), rep("E[T_MRCA]", n))
                       )
ggplot(data, aes(x=x, y=y, linetype=factor(stat))) +
  geom_line(linewidth=1.2) + xlab("n") + ylab("") +
  guides(linetype=guide_legend(title="Statistic"))
```

:::

::: {.notes}

Adding a sample only adds $2/n$ to the total tree length. Also, adding
a sample will add little to $T_{MRCA}$, or equivalently, will most
likely add a very recent coalescent event to the tree for large enough
$n$. Note that $n=20$ here is equivalent to 10 diploid individuals.

:::

## Adding mutations

:::: {.columns}

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-add-mutations
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 500px
#| fig-cap:
#|   Adding mutations on a coalescent genealogy.
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=10pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=120px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=80px] (4) {}
node at ($(1) !.5! (4)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(4) !.6! (root) $) (6) {}
node at ($(2) !.5! (6) $) (5) {}
node[above of=root, node distance=10px, outer sep=10px] (ancestral) {00000}
node[below of=1, rotate=60, node distance=8px, anchor=south east] (l1) {11000}
node[below of=2, rotate=60, node distance=8px, anchor=south east] (l2) {00110}
node[below of=3, rotate=60, node distance=8px, anchor=south east] (l3) {00100}
node[below of=4, rotate=60, node distance=8px, anchor=south east] (l4) {00001}
node at ($(1) !.33! (root) - (.5, 0)$) (m1l) {0}
node at ($(1) !.33! (root) + (.5, 0)$) (m1r) {1}
node at ($(1) !.67! (root) - (.5, 0)$) (m2l) {0}
node at ($(1) !.67! (root) + (.5, 0)$) (m2r) {1}
node at ($(2) !.5! (5) - (.5, 0)$) (m3l) {0}
node at ($(2) !.5! (5) + (.5, 0)$) (m3r) {1}
node at ($(5) !.5! (6) - (.5, 0)$) (m4l) {0}
node at ($(5) !.5! (6) + (.5, 0)$) (m4r) {1}
node at ($(4) !.5! (6) - (.5, 0)$) (m5l) {0}
node at ($(4) !.5! (6) + (.5, 0)$) (m5r) {1}
;
\draw
(1) -- (root)
(4) -- (root)
(2) -- (6)
(3) -- (5);
\draw[>=latex, ->] (m1l) -- (m1r);
\draw[>=latex, ->] (m2l) -- (m2r);
\draw[>=latex, ->] (m3l) -- (m3r);
\draw[>=latex, ->] (m4l) -- (m4r);
\draw[>=latex, ->] (m5l) -- (m5r);

\end{tikzpicture}
```

:::

::: {.column width="50%"}

Mutations are added by "throwing" them on branches, where the
probability of ending up on a given branch is equal to its relative
length.

The total number of segregating sites $S$ to be thrown on the tree is
modelled as a [Poisson random
variable](https://en.wikipedia.org/wiki/Poisson_distribution) which
expresses the probability of a given number of events in a given time.
Here the time is the total branch length of the tree and mutations are
added with intensity proportional to the **population mutation rate**
$\theta$.

:::

::::

::: {.notes}

Sofar we have looked at genealogies; now add mutations.

In words: sample a number of segregating sites from the Poisson
distribution, and "sprinkle" them on the tree.

The parametrization $\lambda = \theta / 2$ is defined with reference
to the average heterozygosity between two sequences being $\theta$ (by
Tajima; see @wakeley_CoalescentTheoryIntroduction_2008, p. 92)

:::

## The coalescent and diversity {.smaller}

:::: {.columns}

::: {.column width="50%"}

::: {.dna}

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]"}

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
\begin{align}
\pi & = \sum_{j=1}^S h_j = \sum_{j=1}^{S} \frac{n}{n-1}\left(1 - \sum_i p_i^2 \right) \\
& \stackrel{S=6,\\ n=4}{=} \sum_{j=1}^{6} \frac{4}{3}\left(1 - \sum_i p_i^2\right) \\
& = \frac{4}{3}\left(\mathbf{\color{#a7c947}{4}}\left(1-\frac{1}{16}-\frac{9}{16}\right) + \mathbf{\color{#a7c947}{2}}\left(1 - \frac{1}{4} - \frac{1}{4}\right)\right) = \frac{10}{3}
\end{align}
$$

<!-- markdownlint-enable MD013 -->

:::

:::

::: {.column width="20%" .fragment}

```{r, engine="tikz", fig.ext="svg" }
#| label: coalescent-tree-dna-variation-representation
#| echo: false
#| eval: true
#| out-width: 80%
\begin{tikzpicture}[outer sep=0, inner sep=0, thick,
                    node distance=5px, every node/.style={font=\ttfamily}]
\tikzstyle{mut} = [circle, minimum height=0.2cm, fill=gray, draw];
\draw
node (1) at (0, 0) {}
node (2) at (1, 0) {}
node (3) at (2, 0) {}
node (4) at (3, 0) {}
node (5) at ($(1) !.5! (2) + (0, 2)$) {}
node (6) at ($(1-|5) !.5! (3) + (0, 3)$) {}
node (7) at ($(1-|6) !.5! (4) + (0, 5)$) {}
node[above of=7, anchor=south] (rootl) {000000}
node[rotate=45, below left of=1, anchor=north east] (1l) {010100}
node[rotate=45, below left of=2, anchor=north east] (2l) {010100}
node[rotate=45, below left of=3, anchor=north east] (3l) {001000}
node[rotate=45, below left of=4, anchor=north east] (4l) {100011}
;

\draw
(1) -- (5)
(2) -- (5)
(5) -- (6)
(3) -- (6)
(6) -- (7)
(4) -- (7)
node[mut] (m1) at ($(5) !.33! (6)$) {}
node[mut] (m2) at ($(5) !.67! (6)$) {}
node[mut] (m3) at ($(3) !.5! (6)$) {}
node[mut] (m4) at ($(4) !.25! (7)$) {}
node[mut] (m5) at ($(4) !.5! (7)$) {}
node[mut] (m6) at ($(4) !.75! (7)$) {}
;
\end{tikzpicture}
```

:::

::: {.column width="30%" .fragment}

```{r, engine="tikz", fig.ext="svg" }
#| label: tree-site-frequency-spectrum-graph
#| echo: false
#| eval: true
#| out-width: 80%
%% https://tex.stackexchange.com/questions/123866/histogram-with-tikz
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=blue!60!black, draw=blue!60!black]
plot coordinates{(0,.8) (1,.4) (2, 0) (3, 0)};
\draw[->] (-0.2, 0) -- (3.2, 0) node[right] {$x$};
\draw[->] (0, -0.2) -- (0, 1.2) node[above] {$y$};
\node[tick] at (0.5, -0.3) {1};
\node[tick] at (1.5, -0.3) {2};
\node[tick] at (2.5, -0.3) {3};
\node[tick] at (1.5, -0.6) {Allele frequency};
\node[tick, rotate=90] at (-0.4, .5) {Proportion};
\end{tikzpicture}
```

::: {.fragment}

In this notation one can show that $\pi$, the nucleotide diversity, is

$$
\begin{equation*}
\begin{split}
\pi & = \frac{\sum_{i=1}^{n-1}i(n-i)\xi_i}{n(n-1)/2} \\
& \stackrel{n=4}{=} \frac{1*(4-1)*4 + 2*(4-2)*2}{6} \\
& = \frac{10}{3}
\end{split}
\end{equation*}
$$

:::

:::

::::

::: {.fragment}

Many statistical quantities can be related to the **site frequency
spectrum** (**SFS**), which is a summary of the frequencies of the
segregating sites. Let $\xi_i$ be the number of chromosomes in the
sample with $i$ minor alleles. In the example above we have $S=6$
mutations on $n=4$ chromosomes.

:::

## The impact of topology on the SFS {.smaller}

:::: {.columns}

::: {.column width="50%"}

Coalescent trees. [{{< fa rectangle-list >}}]({{< var recipes.slides >}}#sec-recipe-msprime-trees)

<!-- markdownlint-disable MD013 -->

:::: {style="display: grid; grid-template-columns: 200px 200px; grid-row-gap: 0px; grid-column-gap: 40px;"}

:::{}

*Neutral*

```{python }
#| label: msprime-trees-neutral
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="neutral", svgid="neutral", size=(200, 250)))
```

:::

:::{}

*Expansion*

```{python }
#| label: msprime-trees-expansion
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="expansion", svgid="expansion", size=(200, 250)))
```

:::

:::{}

*Bottleneck*

```{python }
#| label: msprime-trees-bottleneck
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="bottleneck", svgid="bottleneck", size=(200, 250)))
```

:::

:::{}

*Selection*

```{python }
#| label: msprime-trees-selection
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="selection", svgid="selection", size=(200, 250)))
```

:::

::::

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

![The SFS under neutrality and selection](assets/images/nielsen-fig2-2005.webp){#fig-sfs-neutrality-selection width=450}

<!-- markdownlint-enable MD013 -->

Many tests for selection are based on the SFS which in turn is
influenced by the topology of the tree.

:::

::::

::: {.notes }

Take home: topologies influence shape of SFS

### Example: Tajima's D

Tests common versus rare alleles. Numerator compares nucleotide
diversity $\pi$ to Watterson's theta, $\theta_W$.

D < 0
: recent population increase *or* positive selection

D > 0
: population contraction *or* balancing selection

:::

## msprime

:::: {.columns}

::: {.column width="60%"}

![Jerome
Kelleher](/slides/simulation/assets/images/jerome.webp){width=30%
fig-align=center}

- Fast & flexible backward-time simulator
- Separates *ancestry* from *mutation* simulation
- Arbitrary discrete demographies / species
- Pedigree support (e.g., 1M+ Quebec ARG)
- Approximate extension to selective sweeps

:::

::: {.column width="40%"}

![msprime](/slides/simulation/assets/images/msprime.webp)\

![demes](/slides/simulation/assets/images/demes.webp)\

:::

::::

## msprime stores data as succinct tree sequences

![Tree sequences [@baumdicker_EfficientAncestryMutation_2022, Fig. 2]](assets/images/baumdicker-2022-fig2.webp){width=700}

## Tree sequences compress data and speedup analyses

:::: {style="display: grid; grid-template-columns: 400px 140px 600px;
220:grid-row-gap: 0px; grid-column-gap: 10px;"}

:::{}

- Compact storage (“domain specific compression”)
- Fast, efficient analysis (a "succinct" structure)
- Well tested, open source (active dev community)

:::

:::{.smallr}

Data compression

:::

:::{}

![](assets/images/tskit-data-compression.svg){width=80%}

:::

:::{}

- Built-in functionality (well documented: <http://tskit.dev>)

::::{.smallr}

...but limited support for major genomic rearrangements (e.g.
inversions, large indels): genomes should be (reasonably) aligned =>
current primary focus = **population genetics**

::::

:::

:::{.smallr}

Speed

:::

:::{}

![](assets/images/tskit-analysis-speed.svg){width=80%}

:::

:::{}
:::

:::{}
:::

:::{.smallest}

::: {.flushright}

Source: [What is a tree sequence? (https://tskit.dev/tutorials/what_is.html)](https://tskit.dev/tutorials/what_is.html)

:::

:::

::::

## tskit terminology: the basics

```{python }
#| label: basic-tree-file
#| echo: false
#| eval: true
#| output: asis
#| fig-format: svg
import treeviz
ts = treeviz.basics_tree()
style = (
    ".node > .lab {font-size: 150%}"
    ".x-axis {font-size: 150%}"
    ".y-axis {font-size: 150%}"
)
print(ts.draw_svg(y_axis=True, y_gridlines=True, time_scale="log_time",
                  y_ticks=[0, 3, 10, 30, 100, 300, 800],
                  size=(1200, 380), style=style))
```

:::{}

- Multiple local trees exist along a genome of fixed length (by
  convention measured in base pairs)
- Genomes exist at specific times, and arerepresented by nodes (the
  same node can persist across many local trees)
- Some nodes are most recent common ancestors (MRCAs) of other nodes
- Entities are zero-based: the rst node has id 0, the second id 1, ...

:::

::: {.flushright}

Images from online tutorial "Terminology & concepts" <https://tskit.dev/tutorials/terminology_and_concepts.html>

:::

## tskit terminology: nodes and edges {.smallest}

:::: {.columns}

::: {.column width="50%"}

```{python }
#| label: tskit-nodes-and-edges
#| echo: false
#| eval: true
#| output: asis
#| fig-format: svg
import treeviz
ts = treeviz.basics_tree()
style = (
    ".node > .lab {font-size: 75%}"
    ".x-axis {font-size: 75%}"
    ".y-axis {font-size: 75%}"
)
print(ts.draw_svg(y_axis=True, y_gridlines=True, time_scale="log_time",
                  y_ticks=[0, 3, 10, 30, 100, 300, 1000],
                  size=(500, 200), style=style))
```

::: {.fragment}

**Nodes (=genomes)**

- exist at a specific [time]{.cbppink .heavy}
- can be [flagged]{.cbpgreen .heavy} as "samples"
- can belong to "[individuals]{.cbporange .heavy}" (e.g., 2 nodes per
  individuals in humans) and, if useful, "[populations]{.cbptomato
  .heavy}"

::: {.small .dna}

<!-- markdownlint-disable MD013 -->

|                id | flags |         population |         individual | [time]{.cbppink-bg} | metadata |
|------------------:|------:|-------------------:|-------------------:|--------------------:|---------:|
|                 0 |     1 |                  0 |                  0 |          0.00000000 |          |
|                 1 |     1 |                  0 | [0]{.cbporange-bg} |          0.00000000 |          |
|                 2 |     1 |                  0 | [1]{.cbporange-bg} |          0.00000000 |          |
|                 3 |     1 | [0]{.cbptomato-bg} | [1]{.cbporange-bg} |          0.00000000 |          |
|                 4 |     1 | [0]{.cbptomato-bg} |                  2 |          0.00000000 |          |
| [5]{.cbpgreen-bg} |     1 | [0]{.cbptomato-bg} |                  2 |          0.00000000 |          |
| [6]{.cbpgreen-bg} |     0 |                  0 |                 -1 |         14.70054184 |          |
|                 7 |     0 |                  0 |                 -1 |         40.95936939 |          |
|                 8 |     0 |                  0 |                 -1 |         72.52965866 |          |
|                 9 |     0 |                  0 |                 -1 |        297.22307150 |          |
|                10 |     0 |                  0 |                 -1 |        340.15496436 |          |
|                11 |     0 |                  0 |                 -1 |        605.35907657 |          |

<!-- markdownlint-enable MD013 -->

:::

:::

:::

::: {.column width="50%"}

::: {.fragment}

**Edges**

- Connect a [parent & child]{.cbppink .heavy}
- Have a [left & right]{.cbpblue .heavy} genomic coordinate
- Usually span multiple trees (e.g., edges connecting nodes 1+7 and
  4+7)

:::{.small .dna}

<!-- markdownlint-disable MD013 -->

| id |             left |               right | [parent]{.cbppink-bg} | [child]{.cbppink-bg} | metadata |
|---:|-----------------:|--------------------:|----------------------:|---------------------:|---------:|
|  0 |                0 |                1000 |                     6 |                    2 |          |
|  1 |                0 |                1000 |                     6 |                    5 |          |
|  2 | [0]{.cbpblue-bg} | [1000]{.cbpblue-bg} |                     7 |                    1 |          |
|  3 | [0]{.cbpblue-bg} | [1000]{.cbpblue-bg} |                     7 |                    4 |          |
|  4 |                0 |                1000 |                     8 |                    3 |          |
|  5 |                0 |                1000 |                     8 |                    6 |          |
|  6 |              307 |                1000 |                     9 |                    0 |          |
|  7 |              307 |                1000 |                     9 |                    7 |          |
|  8 |                0 |                 307 |                    10 |                    0 |          |
|  9 |                0 |                 567 |                    10 |                    8 |          |
| 10 |              307 |                 567 |                    10 |                    9 |          |
| 11 |                0 |                 307 |                    11 |                    7 |          |
| 12 |              567 |                1000 |                    11 |                    8 |          |
| 13 |              567 |                1000 |                    11 |                    9 |          |
| 14 |                0 |                 307 |                    11 |                   10 |          |

<!-- markdownlint-enable MD013 -->

:::

:::

:::

::::

## tskit terminology: sites and mutations

:::: {.columns}

::: {.column width="50%"}

```{python }
#| label: tskit-sites-and-mutations-1
#| echo: false
#| eval: true
#| output: asis
#| fig-format: svg
import treeviz
ts = treeviz.treemut()
style = (
    ".node > .lab {font-size: 75%} "
    ".x-axis {font-size: 75%} "
    ".y-axis {font-size: 75%} "
    ".mut .sym {stroke: none} "
    ".mut .lab {fill: none} "
    ".site  {stroke-width: 1px} "
)
css_string = "#tsmut1 {" + style + "}"

print(ts.draw_svg(y_axis=True, y_gridlines=True, time_scale="log_time",
                  y_ticks=[0, 3, 10, 30, 100, 300, 1000],
                  size=(500, 200), style=css_string,
                  root_svg_attributes={'id': 'tsmut1'}))

```

:::

::: {.column width="50%"}

This is how we can encode genetic variation. Most genomic positions do
not vary between genomes: usually we don’t bother tracking these.

:::

::::

## tskit terminology: sites and mutations

:::: {.columns}

::: {.column width="50%"}

```{python }
#| label: tskit-sites-and-mutations-2
#| echo: false
#| eval: true
#| output: asis
#| fig-format: svg
import treeviz
ts = treeviz.treemut()
style = (
    ".node > .lab {font-size: 75%} "
    ".x-axis {font-size: 75%} "
    ".y-axis {font-size: 75%} "
    ".mut .sym {stroke: none} "
    ".mut .lab {fill: none} "
    ".site  {stroke-width: 1px} "
    ".site.s0 .sym {stroke: #D55E00; stroke-width: 3px} "
)
css_string = "#tsmut2 {" + style + "}"
print(ts.draw_svg(y_axis=True, y_gridlines=True, time_scale="log_time",
                  y_ticks=[0, 3, 10, 30, 100, 300, 1000],
                  size=(500, 200), style=css_string,
                  root_svg_attributes={'id': 'tsmut2'}))
```

:::{}

We can create a [site]{.cbptomato .heavy} at a given genomic
[position]{.cbpgreen .heavy} with a fixed [ancestral state]{.cbpblue
.heavy}.

:::{.dna .smallr}

| id |           position |  ancestral_state | metadata |
|---:|-------------------:|-----------------:|---------:|
|  0 | [52]{.cbpgreen-bg} | [C]{.cbpblue-bg} |          |
|  1 |                200 |                A |          |
|  2 |                335 |                A |          |
|  3 |                354 |                A |          |
|  4 |                474 |                G |          |
|  5 |                523 |                A |          |
|  6 |                774 |                C |          |
|  7 |                796 |                C |          |
|  8 |                957 |                A |          |

:::

:::

:::

::: {.column width="50%"}

This is how we can encode genetic variation. Most genomic positions do
not vary between genomes: usually we don’t bother tracking these.

:::

::::

## tskit terminology: sites and mutations

:::: {.columns}

::: {.column width="50%"}

```{python }
#| label: tskit-sites-and-mutations-3
#| echo: false
#| eval: true
#| output: asis
#| fig-format: svg
import treeviz
style = (
    ".node > .lab {font-size: 75%} "
    ".x-axis {font-size: 75%} "
    ".y-axis {font-size: 75%} "
    ".site  {stroke-width: 1px} "
    ".site.s0 .sym {stroke: #D55E00; stroke-width: 3px} "
)
css_string = "#tsmut3 {" + style + "}"
ts = treeviz.treemut()
print(ts.draw_svg(y_axis=True, y_gridlines=True, time_scale="log_time",
                  y_ticks=[0, 3, 10, 30, 100, 300, 1000],
                  size=(500, 200), style=css_string,
                  root_svg_attributes={'id': 'tsmut3'}))
```

:::{}

We can create a [site]{.cbptomato .heavy} at a given genomic
[position]{.cbpgreen .heavy} with a fixed [ancestral state]{.cbpblue
.heavy}.

:::{.dna .smallr}

| id |           position |  ancestral_state | metadata |
|---:|-------------------:|-----------------:|---------:|
|  0 | [52]{.cbpgreen-bg} | [C]{.cbpblue-bg} |          |
|  1 |                200 |                A |          |
|  2 |                335 |                A |          |
|  3 |                354 |                A |          |
|  4 |                474 |                G |          |
|  5 |                523 |                A |          |
|  6 |                774 |                C |          |
|  7 |                796 |                C |          |
|  8 |                957 |                A |          |

:::

:::

:::

::: {.column width="50%"}

This is how we can encode genetic variation. Most genomic positions do
not vary between genomes: usually we don’t bother tracking these.

:::{}

Normally, a site is created in order to place one or [more]{.cbporange
.heavy} [mutations]{.cbptomato .heavy} at that site

::: {.dna .smallr}

| id |               site | node |         time | derived_state | parent | metadata |
|---:|-------------------:|-----:|-------------:|--------------:|-------:|---------:|
|  0 |                  0 |    8 | 247.85988972 |             T |     -1 |          |
|  1 |                  1 |    0 | 169.80687857 |             C |     -1 |          |
|  2 |                  2 |    3 |  31.84262397 |             C |     -1 |          |
|  3 | [3]{.cbporange-bg} |    9 | 326.26095349 |             C |     -1 |          |
|  4 | [3]{.cbporange-bg} |    7 |  71.04212649 |             T |      3 |          |
|  5 |                  4 |    3 |  42.72352948 |             C |     -1 |          |
|  6 |                  5 |    7 |  55.44045835 |             T |     -1 |          |
|  7 |                  6 |    0 | 259.82567754 |             T |     -1 |          |
|  8 |                  7 |    8 | 169.87040769 |             G |     -1 |          |
|  9 |                  8 |    0 |  42.47396523 |             C |     -1 |          |

:::

:::

:::

::::

## Bibliography {.unnumbered .unlisted .smaller}

::: { #refs }
:::
