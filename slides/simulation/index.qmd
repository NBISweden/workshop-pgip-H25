---
title: Simulation
subtitle: Primer on the coalescent and forward simulation
author:
  - Per Unneberg
format:
  nbis-quarto-revealjs:
    footer: Simulation
    toc: false
---

## Setup  {visibility="hidden" .hidden .unnumbered .unlisted}

{{< include /slides/_knitr.qmd >}}

{{< include /slides/_rlibs.qmd >}}

```{r libs}
#| echo: false
#| eval: true
#| cache: false
library(ape)
library(gganimate)
library(patchwork)
library(igraph)
library(ggraph)
library(tidygraph)
```

## Intended learning outcomes {.unnumbered .unlisted}

Introduction to the coalescent and simulation in msprime, with two
exercises on the coalescent and msprime. The students should be able
to:

- Describe need for simulations
- Demonstrate the coalescent step by step
- Detail some properties of coalescent trees
- Define the site-frequency spectrum
- Describe the coalescent with recombination
- Perform simple simulations in msprime

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-1
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 70%
#| fig-align: center
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
    geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

::: {.notes}

:::

### Recap

Model of a population describing **genealogies** under the following assumptions

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

::: {.fragment}

**Forward** simulation

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## The Wright-Fisher model and simulations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-2
#| echo: false
#| eval: true
#| fig-cap: Wright-Fisher model for 50 generations, 30 individuals
#| out-width: 70%
#| fig-align: center
set.seed(132)
g <- wright_fisher_pop(n = 30, generations = 50)
x_range <- range(vertex_attr(g, "x"))
y_range <- range(vertex_attr(g, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 4, x_range[2])
g %>%
  mutate(
    allele =
      ifelse(degree(., mode = "out") > 0,
        "b", "a"
      )
  ) %>%
  ggplot_wf(., fill = allele) +
    geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r }
#| label: fig-wf-model-reproductive-success-graph
#| echo: false
#| eval: true
#| cache: false
#| fig-cap:
#|    Reproductive success in percent per generation.
#| out-width: 55%
#| fig-align: center
gdf <- g %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0, "b", "a")) %>%
  as.data.frame()
x <- tapply(gdf$allele, gdf$y, function(x) {
  sum(x == "b") / length(x)
})
xmean <- sprintf("%.1f%%", mean(x) * 100)
df <- data.frame(x = seq_along(x), y = x)
ggplot(subset(df, x < 50), aes(x = x, y = y * 100)) +
  geom_line(linewidth=1.2) +
  xlab("Generation") +
  ylab("Reproductive success (%)") +
  theme(text=element_text(size=36))
```

:::{.small .translatey50}

Mean reproductive success = `r sprintf("%.1f%%", mean(x) * 100)`. Can
show for large populations P(no descendants)=$1 - e^{-1} \approx
0.632$

:::

:::

::::

::: {.notes }

[p. 15 @hein2005gene] shows the fraction of genes without descendants.
Focus on the number of descendants for *one* gene *i*, which is X ~
Bin(2N, 1/2N). Since E(X)=1, for large 2N, X is almos Po(1), such that
P(no descendants) = P(X=0) = e^{-1}

Low reproductive success: forward simulations costly!

:::

## Forward and backward simulation {.smaller}

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

:::: {.columns}

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-forward
#| echo: false
#| eval: true
#| fig-cap:
#|    Forward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-backward
#| echo: false
#| eval: true
#| fig-cap:
#|    Backward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[2],
      xend = x1, yend = y_range[1]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

Simulated nodes are filled with black. Genealogy of interest is
highlighted in thick black lines.

::: {.notes}

Forward simulations: require that we keep track of the entire
population -> computationally challenging.

Backward simulations: require only tracking the sample -> quicker.
However, cannot model selection.

:::

## Why do we want simulations anyway?

::: {.incremental}

Null model
: Generate neutral null distributions to compare with observed data

Exploration
: Use to gain understanding and improve interpretation of mutational
  processes

Mathematical complexity
: No analytical solutions for linked selection and the like
  $\rightarrow$ must use simulations

Benchmarking
: Use to generate test data with known properties on which to test and
  evaluate new methods

Model training
: Generate training data for machine learning, e.g., Approximate
  Bayesian Computation (ABC) or Neural Networks (NNs)

:::

# The coalescent

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-1
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

NB: only the samples on the genealogy are needed, but the entire
population is shown as a means to compare with forward simulations.

:::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label=mut),
                 angle_calc="along", label_size=18) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

## Coalescent simulations

:::: {.columns}

::: {.column width="50%"}

The coalescent simulates the genealogy of a **sample** of individuals
on which mutations are "sprinkled" according to a Poisson process.

1. Simulate ancestry (genealogy)
2. Simulate mutations

<h4>Exercise</h4>

How many mutations are common to all samples? How many mutations does
sample 1 have? Sample 2?

Assuming the ancestral state is denoted `0` (prior to the *first*
generation) and the derived state `1`, what are the sequences of the
samples?

:::

::: {.column width="50%"}

```{r}
#| label: wf-model-genealogy-backward-mutations-1
#| echo: false
#| eval: true
#| out-width: 75%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
y_range <- c(y_range[1], y_range[2] + 1)
sample_nodes <- c(152, 155, 158)
i <- V(obj)[unlist(ego(obj, order = 16, nodes = sample_nodes, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)$mut <- ""
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
V(obj)[i]$allele <- "A"
V(obj)$sample <- ""
V(obj)[sample_nodes]$sample <- c(1,2,3)
set.seed(23)
E(obj)[sample(E(obj)[.to(i)], 5)]$mut <- "*"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width, label=mut),
                 angle_calc="along", label_size=18) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele), color = "black", shape = 21, size = 3) +
  scale_fill_manual(values=list(a="white", A="black")) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  geom_node_text(aes(label = sample), size=10, vjust=1.5) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

Answers to exercise: 2 mutations are common to all samples. Sample 1
has 3 mutations, sample 2 has 4.

(arbitrarily) ordering the sites from top to bottom (oldest mutation
comes first), the sequences are:

1: 11100
2: 11101
3: 11010

:::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-1
#| echo: false
#| eval: true
#| out-height: 600px
#| out-width: 500px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\useasboundingbox (t5l.south west) rectangle (t1r.north east);
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-2
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[leaf, right of=3, node distance=60px] (4) {}
node[leaf, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-3
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black,minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[selected, right of=3, node distance=60px] (4) {}
node[selected, right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes

2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-4
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-5
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-6
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[leaf] (1) {}
node[leaf, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-7
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node[selected] (1) {}
node[selected, right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-8
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[leaf, right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf] at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-9
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node[leaf] at ($(1) !.6! (root) $) (8) {}
node[leaf] at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-10
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[leaf, above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: simulate-genealogy-11
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 600px
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          selected/.style={circle,fill=black, minimum size=7pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
(4) -- (6)
(5) -- (6)
(1) -- (7)
(2) -- (7)
(7) -- (8)
(3) -- (8)
(8) -- (root)
(6) -- (root)
;
\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\begin{scope}
\clip (0, 0) rectangle (0, 0);
\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{scope}
\end{tikzpicture}
```

:::

::::

## Simulating genealogies [@hahn_MolecularPopulationGenetics_2019, p. 115]

:::: {.columns}

::: {.column width="50%"}

1. Start with $i=n$ chromosomes
2. Choose time to next coalescent event from an exponential
    distribution with parameter $\lambda=i(i-1)/2$$^1$
3. Choose two chromosomes at random to coalesce
4. Merge the two lineages and set $i \rightarrow i - 1$
5. If $i>1$, go to step 2; if not, stop.

::: {.smallr}

$^1$: The exponential can be parametrized in two different ways, so
that the parameter to the function is either $\lambda$ or
$\beta=1/\lambda$.

:::

:::

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-simulate-genealogy-end
#| echo: false
#| eval: true
#| fig-align: center
#| fig-cap:
#|   A simulated genealogy. The $T_i$ represent the
#|   waiting time when the state has $i$ chromosomes.
#| out-width: 60%
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=60px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=60px] (4) {}
node[right of=4, node distance=20px] (5) {}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(1) !.3! (root) $) (7) {}
node at ($(1) !.6! (root) $) (8) {}
node at ($(5) !.1! (root) $) (6) {}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::::

## Some properties of the tree {.smaller}

:::: {.columns}

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-genealogy-properties
#| echo: false
#| eval: true
#| fig-cap:
#|   A coalescent tree with numbered nodes. Nodes 1-5 correspond
#|   to the samples and are leaves. The internal nodes 6-8 (and the
#|   unlabelled root) are ancestral chromosomes (unsampled). The
#|   $T_i$ represent the waiting time when the state has $i$ chromosomes,
#|   whereas $\tau_i$ correspond to the branch length from node $i$
#|   to its parent.
#| fig-align: center
#| out-width: 60%
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=5pt},
          level distance=100px,
          every node/.style={font=\Large},
          every label/.style={font=\sffamily\Large}
          ]

\draw
node[leaf, label={[yshift=-25pt]1}] (1) {1}
node[leaf, label={[yshift=-25pt]2}, right of=1, node distance=60px] (2) {2}
node[leaf, label={[yshift=-25pt]3}, right of=2, node distance=80px] (3) {3}
node[leaf, label={[yshift=-25pt]4}, right of=3, node distance=60px] (4) {4}
node[leaf, label={[yshift=-25pt]5}, right of=4, node distance=20px] (5) {5}
node at ($(1) !.5! (5)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node[leaf, label={[xshift=10pt]7}] at ($(1) !.3! (root) $) (7) {7}
node[leaf, label={[xshift=10pt]8}] at ($(1) !.6! (root) $) (8) {8}
node[leaf, label={[xshift=10pt]6}] at ($(5) !.1! (root) $) (6) {6}
node[left of=1, node distance=40px] (t5l) {}
node[right of=5, node distance=40px] (t5r) {}
node at ($(t5l |- 6)$) (t4l) {}
node at ($(t5r |- 6)$) (t4r) {}
node at ($(t4l |- 7)$) (t3l) {}
node at ($(t4r |- 7)$) (t3r) {}
node at ($(t3l |- 8)$) (t2l) {}
node at ($(t3r |- 8)$) (t2r) {}
node at ($(t2l |- root)$) (t1l) {}
node at ($(t2r |- root)$) (t1r) {}
;

\draw
(1) -- (root)
(5) -- (root)
(7) -- (2)
(8) -- (3)
(4) -- (6)
;

\draw
node at ($(1) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_1}$}
node at ($(2) !.5! (7) - (10pt, 0)$) () {$\mathbf{\tau_2}$}
node at ($(3) !.45! (8) - (10pt, 0)$) () {$\mathbf{\tau_3}$}
node at ($(4) !.5! (6) - (10pt, 0)$) () {$\mathbf{\tau_4}$}
node at ($(5) !.5! (6) + (10pt, 0)$) () {$\mathbf{\tau_5}$}
node at ($(6) !.5! (root) + (10pt, 0)$) () {$\mathbf{\tau_6}$}
node at ($(7) !.5! (8) - (10pt, 0)$) () {$\mathbf{\tau_7}$}
node at ($(8) !.5! (root) - (10pt, 0)$) () {$\mathbf{\tau_8}$}
;


\draw
node at ($(t5r) !.5! (t4r)$) (T5) {$T_5$}
node at ($(t4r) !.5! (t3r)$) (T4) {$T_4$}
node at ($(t3r) !.5! (t2r)$) (T3) {$T_3$}
node at ($(t2r) !.5! (t1r)$) (T2) {$T_2$}
;

\draw[dotted]
(t5l) -- (t5r)
(t4l) -- (t4r)
(t3l) -- (t3r)
(t2l) -- (t2r)
(t1l) -- (t1r)
;
\end{tikzpicture}
```

:::

::: {.column width="50%"}

Expected waiting time to coalesce when $i$ lineages: $E(T_i) =
\frac{2}{i(i-1)}$

Branch lengths can be derived from waiting times. For instance,
$\tau_1=\tau_2=T_5+T_4$ and $\tau_4=\tau_5=T_5$

Time to the **most recent common ancestor (MRCA)** is sum of wating
times: $T_{MRCA} = \sum_{i=2}^n T_i$

with expected value $E(T_{MRCA}) = \sum_{i=2}^nE(T_i) = 2\left(1 -
\frac{1}{n}\right)$

The expected **total tree height** is $E(T_{total}) = \sum_{i=2}^n
iE(T_i) = 2\sum_{i=2}^n\frac{1}{i-1}$

:::

::::

::: {.notes}

Note that the parametrization is in 2N generations (continuous time
approximation); some use N, others 4N, and so on.

Expected waiting time: the first expression follows from the fact that
the waiting time, given $i$ chromosomes, is exponentially distributed
with parameter $\lambda=i(i-1)/2$. For an exponentially distributed
variable $X$, the expected value is simply $E(X)=1/\lambda$.

Other relations are most easily derived by studying the tree and
summing up relevant branches or time intervals.

:::

## Coalescent simulations vary in topology and height {.smaller}

```{python }
#| label: msprime-simulations
#| cache: false
#| echo: true
#| eval: true
#| code-fold: true
import msprime
seeds = [12, 15, 16, 34, 63, 30]
trees = [msprime.sim_ancestry(3, random_seed=x) for x in seeds]
```

:::{}

```{python }
#| label: fig-coalescent-trees-with-msprime
#| echo: false
#| eval: true
#| fig-format: svg
#| out-width: 80%
#| output: asis
#| fig-cap:
#|     Examples of coalescent simulations. Note the variation in tree
#|     topology and height.
kwargs = dict(x_axis=False, node_labels={},
              symbol_size=0, style=".edge {stroke-width: 2px}",
              root_svg_attributes={"id": "msprime-simulation"})
ymax = 500
tmrca = [ts.node(ts.first().root).time for ts in trees]
for i, ts in enumerate(trees):
    y = tmrca[i] / max(tmrca) * ymax
    print(ts.draw_svg(size=(200, y), **kwargs))
```

:::

Examples of coalescent simulations. Note the variation in tree
topology and height.

## Diminishing returns of adding more samples

:::{}

```{r }
#| label: fig-coalescent-diminishing-returns
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 6
#| fig-align: center
#| out-width: 80%
#| fig-cap:
#|     Dependence of $E[T_{MRCA}]$ and $E[T_{total}]$ on the
#|     sample size n. Already at low values of n the value of
#|     $E[T_{MRCA}]$ is close to its asymptotic value, which has
#|     practical consequences for the measurement of DNA variation.
#|     Adapted from @wakeley_CoalescentTheoryIntroduction_2008,
#|     Fig. 3.3.
n <- 20
t_total <- function(n) {2*sum(1/(seq(2,n)-1))}
t_mrca <- function(n) {2*(1 - 1/n)}

data <- data.frame(y=c(c(0, unlist(lapply(2:n, t_total))),
                       c(0, unlist(lapply(2:n, t_mrca)))),
                       x=c(1:n, 1:n),
                       stat=c(rep("E[T_total]", n), rep("E[T_MRCA]", n))
                       )
ggplot(data, aes(x=x, y=y, linetype=factor(stat))) +
  geom_line(linewidth=1.2) + xlab("n") + ylab("") +
  guides(linetype=guide_legend(title="Statistic"))
```

:::

::: {.notes}

Adding a sample only adds $2/n$ to the total tree length. Also, adding
a sample will add little to $T_{MRCA}$, or equivalently, will most
likely add a very recent coalescent event to the tree for large enough
$n$. Note that $n=20$ here is equivalent to 10 diploid individuals.

:::

## Adding mutations

:::: {.columns}

::: {.column width="50%"}

```{tikz, fig.ext="svg" }
#| label: fig-add-mutations
#| echo: false
#| eval: true
#| out-width: 500px
#| out-height: 500px
#| fig-cap:
#|   Adding mutations on a coalescent genealogy.
\begin{tikzpicture}[
          ultra thick, inner sep=0, outer sep=0,
          leaf/.style={circle,fill=black,minimum size=10pt},
          level distance=100px,
          every node/.style={font=\Large},
          ]
\draw
node (1) {}
node[right of=1, node distance=120px] (2) {}
node[right of=2, node distance=80px] (3) {}
node[right of=3, node distance=80px] (4) {}
node at ($(1) !.5! (4)$) (mid) {}
node[above of=mid, node distance=300px] (root) {}
node at ($(4) !.6! (root) $) (6) {}
node at ($(2) !.5! (6) $) (5) {}
node[above of=root, node distance=10px, outer sep=10px] (ancestral) {00000}
node[below of=1, rotate=60, node distance=8px, anchor=south east] (l1) {11000}
node[below of=2, rotate=60, node distance=8px, anchor=south east] (l2) {00110}
node[below of=3, rotate=60, node distance=8px, anchor=south east] (l3) {00100}
node[below of=4, rotate=60, node distance=8px, anchor=south east] (l4) {00001}
node at ($(1) !.33! (root) - (.5, 0)$) (m1l) {0}
node at ($(1) !.33! (root) + (.5, 0)$) (m1r) {1}
node at ($(1) !.67! (root) - (.5, 0)$) (m2l) {0}
node at ($(1) !.67! (root) + (.5, 0)$) (m2r) {1}
node at ($(2) !.5! (5) - (.5, 0)$) (m3l) {0}
node at ($(2) !.5! (5) + (.5, 0)$) (m3r) {1}
node at ($(5) !.5! (6) - (.5, 0)$) (m4l) {0}
node at ($(5) !.5! (6) + (.5, 0)$) (m4r) {1}
node at ($(4) !.5! (6) - (.5, 0)$) (m5l) {0}
node at ($(4) !.5! (6) + (.5, 0)$) (m5r) {1}
;
\draw
(1) -- (root)
(4) -- (root)
(2) -- (6)
(3) -- (5);
\draw[>=latex, ->] (m1l) -- (m1r);
\draw[>=latex, ->] (m2l) -- (m2r);
\draw[>=latex, ->] (m3l) -- (m3r);
\draw[>=latex, ->] (m4l) -- (m4r);
\draw[>=latex, ->] (m5l) -- (m5r);

\end{tikzpicture}
```

:::

::: {.column width="50%"}

Mutations are added by placing them on branches, where the probability
of ending up on a branch $\tau_i$ is equal to its normalized
length, where normalization is by the total tree branch length:

$$
P(\text{mutation on branch }i) = \frac{\tau_i}{\sum_j\tau_j} =
\frac{\tau_i}{T_{total}}
$$

The total number of segregating sites $S$ to be thrown on the tree is
modelled as a [Poisson random
variable](https://en.wikipedia.org/wiki/Poisson_distribution) which
expresses the probability of a given number of events in time $t$:

$$
S = Po(\theta/2T_{total})
$$

:::

::::

::: {.notes}

Sofar we have looked at genealogies; now add mutations.

In words: sample a number of segregating sites from the Poisson
distribution, and "sprinkle" them on the tree.

The parametrization $\lambda = \theta / 2$ is defined with reference
to the average heterozygosity between two sequences being $\theta$ (by
Tajima; see @wakeley_CoalescentTheoryIntroduction_2008, p. 92)

:::

## The coalescent and diversity {.smaller}

:::: {.columns}

::: {.column width="50%"}

::: {.dna}

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6]"}

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
\begin{align}
\pi & = \sum_{j=1}^S h_j = \sum_{j=1}^{S} \frac{n}{n-1}\left(1 - \sum_i p_i^2 \right) \\
& \stackrel{S=6,\\ n=4}{=} \sum_{j=1}^{6} \frac{4}{3}\left(1 - \sum_i p_i^2\right) \\
& = \frac{4}{3}\left(\mathbf{\color{#a7c947}{4}}\left(1-\frac{1}{16}-\frac{9}{16}\right) + \mathbf{\color{#a7c947}{2}}\left(1 - \frac{1}{4} - \frac{1}{4}\right)\right) = \frac{10}{3}
\end{align}
$$

<!-- markdownlint-enable MD013 -->

:::

:::

::: {.column width="20%" .fragment}

```{r, engine="tikz", fig.ext="svg" }
#| label: coalescent-tree-dna-variation-representation
#| echo: false
#| eval: true
#| out-width: 80%
\begin{tikzpicture}[outer sep=0, inner sep=0, thick,
                    node distance=5px, every node/.style={font=\ttfamily}]
\tikzstyle{mut} = [circle, minimum height=0.2cm, fill=gray, draw];
\draw
node (1) at (0, 0) {}
node (2) at (1, 0) {}
node (3) at (2, 0) {}
node (4) at (3, 0) {}
node (5) at ($(1) !.5! (2) + (0, 2)$) {}
node (6) at ($(1-|5) !.5! (3) + (0, 3)$) {}
node (7) at ($(1-|6) !.5! (4) + (0, 5)$) {}
node[above of=7, anchor=south] (rootl) {000000}
node[rotate=45, below left of=1, anchor=north east] (1l) {010100}
node[rotate=45, below left of=2, anchor=north east] (2l) {010100}
node[rotate=45, below left of=3, anchor=north east] (3l) {001000}
node[rotate=45, below left of=4, anchor=north east] (4l) {100011}
;

\draw
(1) -- (5)
(2) -- (5)
(5) -- (6)
(3) -- (6)
(6) -- (7)
(4) -- (7)
node[mut] (m1) at ($(5) !.33! (6)$) {}
node[mut] (m2) at ($(5) !.67! (6)$) {}
node[mut] (m3) at ($(3) !.5! (6)$) {}
node[mut] (m4) at ($(4) !.25! (7)$) {}
node[mut] (m5) at ($(4) !.5! (7)$) {}
node[mut] (m6) at ($(4) !.75! (7)$) {}
;
\end{tikzpicture}
```

:::

::: {.column width="30%" .fragment}

```{r, engine="tikz", fig.ext="svg" }
#| label: tree-site-frequency-spectrum-graph
#| echo: false
#| eval: true
#| out-width: 80%
%% https://tex.stackexchange.com/questions/123866/histogram-with-tikz
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=blue!60!black, draw=blue!60!black]
plot coordinates{(0,.8) (1,.4) (2, 0) (3, 0)};
\draw[->] (-0.2, 0) -- (3.2, 0) node[right] {$x$};
\draw[->] (0, -0.2) -- (0, 1.2) node[above] {$y$};
\node[tick] at (0.5, -0.3) {1};
\node[tick] at (1.5, -0.3) {2};
\node[tick] at (2.5, -0.3) {3};
\node[tick] at (1.5, -0.6) {Allele frequency};
\node[tick, rotate=90] at (-0.4, .5) {Proportion};
\end{tikzpicture}
```

::: {.fragment}

In this notation one can show that $\pi$, the nucleotide diversity, is

$$
\begin{equation*}
\begin{split}
\pi & = \frac{\sum_{i=1}^{n-1}i(n-i)\xi_i}{n(n-1)/2} \\
& \stackrel{n=4}{=} \frac{1*(4-1)*4 + 2*(4-2)*2}{6} \\
& = \frac{10}{3}
\end{split}
\end{equation*}
$$

:::

:::

::::

::: {.fragment}

Many statistical quantities can be related to the **site frequency
spectrum** (**SFS**), which is a summary of the frequencies of the
segregating sites. Let $\xi_i$ be the number of chromosomes in the
sample with $i$ minor alleles. In the example above we have $S=6$
mutations on $n=4$ chromosomes.

:::

## The impact of topology on the SFS {.smaller}

:::: {.columns}

::: {.column width="50%"}

Coalescent trees. [{{< fa rectangle-list >}}]({{< var recipes.slides >}}#sec-recipe-msprime-trees)

<!-- markdownlint-disable MD013 -->

:::: {style="display: grid; grid-template-columns: 200px 200px; grid-row-gap: 0px; grid-column-gap: 40px;"}

:::{}

*Neutral*

```{python }
#| label: msprime-trees-neutral
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="neutral", svgid="neutral", size=(200, 250)))
```

:::

:::{}

*Expansion*

```{python }
#| label: msprime-trees-expansion
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="expansion", svgid="expansion", size=(200, 250)))
```

:::

:::{}

*Bottleneck*

```{python }
#| label: msprime-trees-bottleneck
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="bottleneck", svgid="bottleneck", size=(200, 250)))
```

:::

:::{}

*Selection*

```{python }
#| label: msprime-trees-selection
#| echo: false
#| eval: true
#| fig-format: svg
#| output: asis
import treeviz
print(treeviz.tree_topology(model="selection", svgid="selection", size=(200, 250)))
```

:::

::::

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

![The SFS under neutrality and selection](assets/images/nielsen-fig2-2005.webp){#fig-sfs-neutrality-selection width=450}

<!-- markdownlint-enable MD013 -->

Many tests for selection are based on the SFS which in turn is
influenced by the topology of the tree.

:::

::::

::: {.notes }

Take home: topologies influence shape of SFS

### Example: Tajima's D

Tests common versus rare alleles. Numerator compares nucleotide
diversity $\pi$ to Watterson's theta, $\theta_W$.

D < 0
: recent population increase *or* positive selection

D > 0
: population contraction *or* balancing selection

:::

# Exercise on the coalescent {.unnumbered .unlisted}

# The coalescent with recombination

::: {.notes}

Introduce the coalescent with recombination which in practice is a
very brief inroduction to the concept of tree sequences.

:::

## On non-recombining chromosomes and assortment {.smaller}

:::: {.columns}

::: {.column width="50%"}

```{r, engine="tikz", fig.ext="svg" }
#| label: non-recombining-chromosomes-assortment-1
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 50%
\tikzstyle{female}=[circle,thick,minimum size=1cm,draw=black]
\tikzstyle{male}=[rectangle,thick,minimum width=1cm, minimum height=1cm, draw=black]
  \begin{tikzpicture}[>=latex,font=\small, thick,
    plab/.style={font=\scriptsize, outer sep=0cm}]
    \node[male, fill=gray] (grandfather) at (0, 8) { };
    \node[female] (grandmother) at (4, 8) { };

\node[inner sep=0cm] (grandparents) at (2, 8) { };

    \node[male, fill=gray] (father) at (2, 4) { };
    \node[female] (mother) at (6, 4) { };

\node[inner sep=0cm] (parents) at (4, 4) { };
\node[inner sep=0cm] (siblings) at (4, 2) { };

    \node[female, fill=gray] (sister1) at (2, 0) { };
    \node[female, fill=gray] (sister2) at (6, 0) { };

\draw (grandfather) -- (grandmother);
\draw (grandparents) -- (father);
\draw (parents) -- (siblings);
\draw (father) -- (mother);
\draw (siblings) -| (sister1);
\draw (siblings) -| (sister2);
\end{tikzpicture}
```

Both siblings inherit chromosome from paternal grandfather

Chromosomes coalesce at father

:::

::: {.column width="50%"}

::: {.fragment}

```{r, engine='tikz', fig.ext='svg' }
#| label: non-recombining-chromosomes-assortment-2
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 50%
\usetikzlibrary{shapes}
\tikzstyle{female}=[circle,thick,minimum size=1cm,draw=black]
\tikzstyle{male}=[rectangle,thick,minimum width=1cm, minimum height=1cm, draw=black]
\tikzstyle{splitmale}=[rectangle split, rectangle split
                       parts=2,thick,minimum width=1cm, minimum
                       height=1cm, draw=black]
  \begin{tikzpicture}[>=latex,font=\small, thick,
    plab/.style={font=\scriptsize, outer sep=0cm}]
    \node[male, fill=gray] (grandfather) at (0, 8) { };
    \node[female, fill=lightgray] (grandmother) at (4, 8) { };

\node[inner sep=0cm] (grandparents) at (2, 8) { };

\node[splitmale, rotate=90, rectangle split part fill={gray,
  lightgray}] (father) at (2, 4) { };
    \node[female] (mother) at (6, 4) { };

\node[inner sep=0cm] (parents) at (4, 4) { };
\node[inner sep=0cm] (siblings) at (4, 2) { };

    \node[female, fill=gray] (sister1) at (2, 0) { };
    \node[female, fill=lightgray] (sister2) at (6, 0) { };

\draw (grandfather) -- (grandmother);
\draw (grandparents) -- (father);
\draw (parents) -- (siblings);
\draw (father) -- (mother);
\draw (siblings) -| (sister1);
\draw (siblings) -| (sister2);
\end{tikzpicture}
```

Siblings inherit different grandparental chromosomes $\Rightarrow$
chromosomes coalesce God knows when in the past

Genealogies **differ**

:::

:::

::::

::: {.notes}

NB: the right genealogy is so small the sequences don't coalesce. The
following slide will show a larger genealogy where all sequence
coalesce.

:::

## The ancestral recombination graph {.smaller}

:::{}

![](assets/images/brandt-genetics-2022-fig1a.webp){fig-align=center, height=300}
![](assets/images/brandt-genetics-2022-fig1b.webp){fig-align=center, height=300}
![](assets/images/brandt-genetics-2022-fig1c.webp){fig-align=center, height=300}

::: {.flushright .smallest}

@y.c.brandt_EvaluationMethodsEstimating_2022 [Fig. 1a]

:::

:::

Properties:

- marginal trees constitute a sequence of trees (**tree sequence**)
  along a chromosome
- each tree represents the genealogy of a non-recombining part of the
  chromosome
- neighbouring trees are **correlated**

Interpretation: chromosomes are mosaics of non-recombining units

::: {.notes}

Going backwards in time, we now have two events to track. We have
already encountered coalescence, that is, the merging of lineages. We
now also need to monitor recombination events, at which point a
genealogy *splits* into two separate paths. A recombination event
takes place on a sequence, such that the genealogical history of the
recombined sequence differs on either side of the recombination
breakpoint. In the ARG, by convention the sequence to the left of the
breakpoint takes the left path, the sequence to the right the right path.

The end consequence of recombination is that the chromosome/sequence
will consist of non-recombining units with different genealogical
histories. However, neighbouring genealogies will be similar - they
are *correlated* - a fact that is of importance for the tree sequence
data structure used in msprime.

:::

## The ancestral recombination graph as sequence of trees

:::: {.columns}

::: {.column width="50%"}

![The ancestral recombination graph as a tree sequence
[@baumdicker_EfficientAncestryMutation_2022, Fig.
5]](assets/images/baumdicker-2022-fig5.webp){height=500
fig-align=center}

:::

::: {.column width="50%"}

Properties:

- marginal trees constitute a sequence of trees (**tree sequence**)
  along a chromosome
- each tree represents the genealogy of a non-recombining part of the
  chromosome
- neighbouring trees are **correlated**

Interpretation: chromosomes are mosaics of non-recombining units

:::

::::

## msprime is a fast coalescent simulator

Original coalescent simulator implementions assumed *small* sample
sizes and could only simulate short recombining sequences. `msprime`
was developed to address these shortcomings as today we have

1. chromosome-level assemblies that require full treatment of
   recombination (*very* complex problem)
2. biobank datasets consisting of 100's of thousands of samples

:::: {.columns}

::: {.column width="50%"}

### Features

- can simulate millions of whole chromosomes
- well-designed mature API
- succinct data structure (tree sequences) has led to advances in
  forwards-time simulation
- can be used together with forwards-time simulators

:::

::: {.column width="50%"}

### Limitations

- assumes neutrality - can't simulate selection
- assumes exchangeability

:::

::::

## msprime stores variation data as tree sequences

![Tree sequences [@baumdicker_EfficientAncestryMutation_2022, Fig. 2]](assets/images/baumdicker-2022-fig2.webp){width=700}

## Tree sequences compress data

![Data compression [@kelleher_InferringWholegenomeHistories_2019, Fig. 1c]](assets/images/kelleher-nature-2019-fig1c.webp){width=700}

## Simulating ancestry with msprime

<!-- markdownlint-disable MD013 -->

From [msprime
quickstart](https://tskit.dev/msprime/docs/stable/quickstart.html)

<!-- markdownlint-enable MD013 -->

```{python }
#| label: sim_ancestry
#| echo: true
#| eval: true
#| fig-format: svg
#| output: asis
#| out-width: 300px
import msprime
# Simulate an ancestral history for 3 diploid samples under the coalescent
# with recombination on a 5kb region with human-like parameters.
ts = msprime.sim_ancestry(
    samples=3,
    recombination_rate=1e-8,
    sequence_length=5_000,
    population_size=10_000,
    random_seed=123456)
print(ts.draw_svg())
```

## Simulating mutations with msprime

```{python }
#| label: sim_mutations
#| echo: true
#| eval: true
#| output: asis
#| fig-format: svg
import msprime
ts = msprime.sim_ancestry(
    samples=3,
    recombination_rate=1e-8,
    sequence_length=5_000,
    population_size=10_000,
    random_seed=123456)
mutated_ts = msprime.sim_mutations(ts, rate=1e-8, random_seed=54321)
print(mutated_ts.draw_svg())
```

# msprime exercise {.unnumbered .unlisted}

# Forward simulation in SLiM

::: {.notes}

This is currently a *very* brief introduction to SLiM. Future versions
of the lecture will add some more detail.

:::

## SLiM

SLiM (**S**election on **Li**nked **M**utations)
[@haller_SLiMForwardGenetic_2019] is a forwards-time simulator. As its
name implies, it models selection and thus is a complement to
coalescent-based simulators.

:::: {.columns}

::: {.column width="50%"}

### Why SLiM?

1. **flexibility** - scripting language *Eidos* allows for modelling
   complex scenarios with little code
2. **performance** - optimized code base
3. **GUI** - interactive execution and graphical debugging

::: {.flushright .smallr}

@haller_SLiMEvolutionarySimulation_2022

:::

:::

::: {.column width="50%"}

![](assets/images/slimgui.webp){width=600 fig-align="center"}

:::

::::

## Forward simulation in SLiM {.smaller}

:::: {.columns}

::: {.column width="50%"}

0. Execution of `first()` events
1. Execution of `early()` events
2. Generation of offspring; for each offspring:
   1. Choose source subpop for parental individuals, based on
      migration rates
   2. Choose parent 1, based on cached fitness values
   3. Choose parent 2, based on fitness and any defined `mateChoice()`
      callbacks
   4. Generate the candidate offspring, with mutation and
      recombination (including `mutation()` and `recombination()`
      callbacks)
   5. Suppress/modify the candidate, using defined `modifyChild()`
      callbacks
3. Removal of fixed mutations unless `convertToSubstitution==F`
4. Offspring become parents
5. Execution of `late()` events
6. Fitness recalculation using `mutationEffect()` and `fitnessEffect()`
   callbacks
7. Tick/cycle count increment

:::

::: {.column width="50%"}

```{r}
#| label: fig-wf-model-genealogy-forward-slim
#| echo: false
#| eval: true
#| fig-cap:
#|    Forward simulation.
#| out-width: 60%
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
x1 <- x_range[1] - 1
x_range <- c(x1 - 3, x_range[2])
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
      geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - 1, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = y_range[1],
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = y_range[2],
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::::

::: {.notes}

SLiM works forward in time according to a *tick cycle*, which
basically is a counter of time steps.

@haller_SLiMForwardGenetic_2019, pp. 603--610 describes the steps in
more details; some clarifying comments are added belowe wrt to the
slide flowchart. There is **a lot** to unpack here, and the summary
flowchart captures most of the essentials.

0. first events: prior to generation of offspring; don't affect
   fitness. Rare use.
1. early: catch-all event to do things before generation of offspring
2. generation of offspring
   1. Choose source subpop for parental individuals, based on
      migration rates
   2. Choose parent 1, based on cached fitness values
   3. Choose parent 2, based on fitness and any defined `mateChoice()`
      callbacks
   4. Generate the candidate offspring, with mutation and
      recombination (including `mutation()` and `recombination()`
      callbacks)
   5. Suppress/modify the candidate, using defined `modifyChild()`
      callbacks
3. Removal of fixed mutations unless `convertToSubstitution==F` - for
   simulation efficiency reasons
4. Offspring become parents
5. Execution of `late()` events - e.g., changing of selection or
   dominance coefficients
6. Fitness recalculation using `mutationEffect()` and `fitnessEffect()`
   callbacks
7. Tick/cycle count increment

:::

## Simple neutral simulation in SLiM {.smaller}

```{r engine="c"}
#| label: slim-example
#| echo: true
#| eval: false
// set up a simple neutral simulation
initialize()
{
// set the overall mutation rate
initializeMutationRate(1e-7);
// m1 mutation type: neutral
initializeMutationType("m1", 0.5, "f", 0.0);
// g1 genomic element type: uses m1 for all mutations
initializeGenomicElementType("g1", m1, 1.0);
// uniform chromosome of length 100 kb
initializeGenomicElement(g1, 0, 99999);
// uniform recombination along the chromosome
initializeRecombinationRate(1e-8);
}
// create a population of 500 individuals
1 early()
{
sim.addSubpop("p1", 500);
}
// run to tick 10000
10000 early()
{
sim.simulationFinished();
}
```

Comes with a huge manual [@haller_SLiMEvolutionarySimulation_2022] (700+
pages!)

## Recapitation - combining the best of two worlds {.smaller}

:::: {style="display: grid; grid-template-columns: 4fr 3fr 3fr;
grid-row-gap: 0px; grid-column-gap: 20px;"}

:::{}

A recent addition to SLiM is that it records data in *tree sequence
format* (as in msprime) {{< fa arrow-right >}} we can combine backward
and forward simulations!

:::

:::{}

::: {.fragment fragment-index=2}

Backward simulation that adds coalescent (neutral) history

:::

:::

:::{}

::: {.fragment fragment-index=2}

:::{style="transform: translate(0, -50px);"}

```{r }
#| label: backward-simulation-recapitation
#| echo: false
#| eval: true
#| out-width: 70%
set.seed(5)
wf <- wright_fisher_pop(n = 10, generations = 11)
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
indices <- (max(V(obj)) - 10 + 1):max(V(obj))
i <- V(obj)[unlist(ego(obj, order = 16, nodes = indices, mode = "in"))]
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  expand_limits(x = x_range, y = y_range)
```

:::

:::

:::

:::{}

:::

:::{}

::: {.fragment fragment-index=1}

Forward simulation with selection or some other process that isn't
supported by the coalescent

:::

:::

:::{}

::: {.fragment fragment-index=1}

:::{style="transform: translate(0, -150px);"}

```{r }
#| label: forward-simulation-recapitation
#| echo: false
#| eval: true
#| out-width: 70%
set.seed(252)
wf <- wright_fisher_pop(n = 10, generations = 6)
obj <- wf
x_range <- range(vertex_attr(obj, "x"))
y_range <- range(vertex_attr(obj, "y"))
E(obj)$color <- "lightgray"
E(obj)$width <- .1
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "black"
  )) +
  geom_node_point(fill = "black", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  expand_limits(x = x_range, y = y_range)
```

:::

:::

:::

::::

# Applications

## Simulation of null distributions {.smaller}

:::{.compact}

![Empirical distribution function of SweepFinder2 composite likelihood
ratio (CLR) scores from observed data versus null simulations for
three populations of squash bee (*E. pruinosa*). msprime was used to
simulate data (without selection) using the inferred demographic model
and recombination map. The eastern population in particular shows
signs of selective sweeps. @pope_ExpansionAgricultureHas_2023, Fig
S8.](assets/images/pope_2023_figs8.webp){#fig-pope-2023-clr width=90%
fig-align=center}

:::

:::{}

Authors inferred demographic history and recombination map. The
inferred values were used to simulate data with msprime. SweepFinder2
[@degiorgio_SweepFinder2IncreasedSensitivity_2016] was used to
calculate composite likelihood ratio (CLR) scores on both observed and
simulated data to assess significance quantiles.

:::

::: {.notes}

The details of the sweep finding / paper are not the main point here;
rather, we want to highlight the use of simulations to generate null
distribution scores (here, for CLR values) such that significance
quantiles can be derived and applied to the observed data.

Original figure legend:

> Empiricial distribution functions of SWEEPFINDER 2 composite
> likelihood ratio (CLR) scores from the observed data and null
> simulations for each major E. pruinosa lineage (log-transformed for
> visualization). The null simulations were generated using the
> inferred demographic model and recombination maps (see Methods in
> main text). The observed and null distributions match each other
> quite closely in the Mexican lineage (MX). In the Western lineage
> (CO), the tail of the CLR score distribution deviates slightly from
> the null simulations. In the Eastern lineage (PA), the tail of the
> observed CLR score distribution is extremely heavy relative to the
> null. This suggests the existence of selective sweeps in both CO and
> PA, but especially in PA

:::

## Simulations of genomic landscapes in monkeyflower{.smaller}

:::: {.columns}

::: {.column width="30%"}

<!-- markdownlint-disable MD013 -->

![Sampling locations](assets/images/stankowski-2019-figs2.webp){#fig-stankowski-figs2 width=80% fig-align=center}

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="70%"}

<!-- markdownlint-disable MD013 -->

![Genomic landscapes simulated under different divergence histories.](assets/images/stankowski-2019-fig7.webp){#fig-stankowski-fig7 width=70% fig-align=center}

<!-- markdownlint-enable MD013 -->

:::

::::

Monkeyflower (*Mimulus aurantiacus*) radiation in California shows
wide adaptive range and phenotypic diversity.
@stankowski_WidespreadSelectionGene_2019 *et al* use simulations (SLiM
and msprime) to shed light on processes that shape genomic landscapes,
which are correlated between species.

::: {.fragment}

We will look more closely at this system tomorrow.

:::

::: {.notes}

Simulations are based on variations of a neutral base model that
starts out with an ancestral population (N=10,000) that after 10N
generation splits to two daughter populations (N=10,000 each) and are
simulated another 10N generations. The chromosome is 21Mbp (similar in
size to a monkeyflower chromosome) consisting of a central neutrally
evolving region flanked by two regions where non-neutral processes are
"allowed". Models are:

1. neutral
2. BGS (non-neutral mutations are deleterious)
3. Bateson-Dobzhansky-Muller incompatibility (BDMI); after split,
   fraction variants deleterious in one population, neutral in other
4. positive selection
5. BGS and positive selection
6. local adaptation; 4 but also after split some variants beneficial
   in one population, neutral in other

Figure caption:

> Fig 7. Genomic landscapes simulated under different divergence
> histories. Each row of plots shows patterns of within- and
> between-population variation (, dxy, and FST) across the chromosome
> (500-kb windows) at 5 time points (N generations, where N = 10,000)
> during one of the scenarios The selection parameter (Ns, where s =
> Ns/N), proportion of deleterious () and positive mutations (+), and
> number of migrants per generation (Nm; 0 unless stated) for these
> simulations are as follows: (i) neutral divergence (no selection),
> (ii) BGS (Ns = 100; prop = 0.1), (iii) BDMI (Ns = 100, prop =
> 0.05, Nm = 0.1), (iv) positive selection (+Ns = 100, +prop = 0.001),
> (v) BGS and positive selection (Ns = 100, prop = 0.1; +Ns = 100,
> +prop = 0.005), and (vi) local adaptation (+Ns = 100, +prop = 0.001,
> Nm = 0.1). The gray boxes in the first column show the areas of the
> chromosome that are experiencing selection, while the white central
> area evolves neutrally. Note that  (in populations a and b) and dxy
> have been mean centered so they can be viewed on the same scale.
> Uncentered values and additional simulations with different
> parameter combinations and more time points can be found in S13 Fig.
> BDMI, Bateson-Dobzhansky-Muller incompatibility; BGS, background
> selection.

:::

## Neural network recombination landscape prediction

<!-- markdownlint-disable MD013 -->

:::{}

![Cartoon of Recombination Landscape Estimation using Recurrent Neural
Networks (ReLERNN) workflow
[@adrion_PredictingLandscapeRecombination_2020]](assets/images/adrion-2020-fig1.webp){#fig-adrion-2020-fig1
fig-align=center width=60%}

:::

<!-- markdownlint-enable MD013 -->

Use msprime simulations to generate training data for neural network.

::: {.notes}

Methods paper; one of the first examples of using msprime simulations
to generate training data for a neural network.

Figure caption:

> A cartoon depicting a typical workflow using ReLERNNs four modules
> (shaded boxes) for (A) individually sequenced genomes or (B) pooled
> sequences. ReLERNN can optionally (dotted lines) utilize output from
> stairwayplot, SMC++, and MSMC to simulate under a demographic
> history with msprime. Training inlays show the network architectures
> used, with the GRU inlay in (B) depicting the gated connections
> within each hidden unit. Here, r, z, ht, and ht are the reset gate,
> update gate, activation, and candidate activation, respectively (Cho
> et al. 2014). The genotype matrix encodes alleles as reference (1),
> alternative (1), or padded/missing data (0; not shown). Variant
> positions are encoded along the real number line (01).

:::

## Bibliography {.unnumbered .unlisted .smaller}

::: { #refs }
:::
