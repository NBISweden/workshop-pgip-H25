---
title: "Population genetics"
subtitle: "Foundations"
author:
  - "Per Unneberg"
format:
  nbis-quarto-revealjs:
    toc: false
    smaller: false
    footer: Population genetics foundations
---

## Setup  {.hidden .unnumbered .unlisted visibility="hidden"}

{{< include ../_knitr.qmd >}}

{{< include ../_rlibs.qmd >}}

```{r libs}
#| echo: false
#| eval: true
#| cache: false
library(viridisLite)
library(gganimate)
library(patchwork)
library(expm)
library(gridExtra)
library(igraph)
library(ggraph)
library(tidygraph)
```

## Intended learning outcomes {.unnumbered .unlisted}

Introduction to foundations of population genetics with an emphasis on
genealogies

- Description of DNA variation data
- Wright-Fisher population model and genealogies
- Genetic drift
- Wright-Fisher model with mutation
- Mutation-drift balance
- Neutral theory
- Selection basics

::: {.notes}

Objective: introduce the foundations of population genetics, with
an emphasis on genealogies. Framing population genetic concepts in
trees will facilitate the introduction of the coalescent in the
afternoon.

The lecture presents sequence data, the Wright-Fisher model,
genetic drift, mutation, and selection. The focus is to
familiarise students with concepts and basic theory.

:::

# DNA variation

:::{}

![](assets/images/popgen.svg)

:::

::: {.notes }

Goal of section: look at the data that forms the foundation for
population genomic analyses

From [@nei_MolecularEvolutionPhylogenetics_2000, p. 231]:

> The main subject of population genetics is to study the generation
> and maintenance of genetic polymorphism and to understand the
> mechanisms of evolution at the population level

[@casillas_MolecularPopulationGenetics_2017, p. 1026]:

> Big data samples of complete genome sequences of many individuals
> from natural populations of many species have transformed population
> genetics inferences on samples of loci to population genomics: the
> analysis of genome-wide patterns of DNA variation within and between
> species.

[@gillespie_PopulationGeneticsConcise_2004, p. 1]

> Population geneticists spend most of their time doing one of two
> things: describing the genetic structure of populations or
> theorizing on the evolutionary forces acting on populations. On a
> good day, these two activities mesh and true insights emerge.

:::

## DNA variation - monomorphic sites

::: {.dna }

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|
| T | T | A | C | A | A | T | C | C | G  | A  | T  | C  | G  | T  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |
| T | C | A | C | A | A | T | G | C | G  | A  | T  | G  | G  | A  |
| T | T | A | C | G | A | T | G | C | G  | C  | T  | C  | G  | T  |
| * |   | * | * |   | * | * |   | * | *  |    | *  |    | *  | T  |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

The alignment has 4 DNA sequences where each sequence has length
$L=15$. A site where all nucleotides (alleles) are identical is called
a *monomorphic* site (indicated with asterisks above). There are 9
monomorphic sites.

## DNA variation - segregating sites

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

A site where there are different nucleotides (alleles) is called a
*segregating* site (indicated with asterisks above), often denoted
*S*. There are $S=6$ segregating sites.

:::: {.columns}

::: {.column width="50%"}

::: {.fragment}

Alternative names for *segregating site* are:

:::

::: {.incremental}

- *polymorphism*
- *mutation*
- *single nucleotide polymorphism (SNP)*

:::

:::

::: {.column width="50%"}

::: {.fragment}

*mutation* here and onwards refers to the process that generates new
variation and the new variants generated by this process

In contrast to *mutation* which corresponds to within-species
variation, a *substitution* refers to DNA differences between species.

:::

:::

::::

## DNA variation - major and minor alleles

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

Much of the nucleotide variation we study consists of *bi-allelic*
SNPs. The most common variant is called the *major* allele, and the
least common the *minor* allele.

The set of alleles found on a single sequence is called *haplotype*.

## Describing DNA variation - heterozygosity {.smaller}

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

Once we have a sample of sequences we want to describe the observed
variation. At any position the *i*th allele has sample frequency
$p_i$, where the sum of all allele frequencies is 1. For instance, at
site 1, $p_T=1$ (and by extension $p_A=p_C=p_G=0$), and at site 2
$p_C=1/4$ and $p_T=3/4$.

:::: {.columns}

::: {.column width="50%"}

::: {.fragment}

<h4>Heterozygosity</h4>

The *heterozygosity* at a site $j$ is given by

$$
h_j = \frac{n}{n-1}\left(1 - \sum_i p_i^2\right)
$$

where the summation is over all alleles and $p_i$ is the frequency of
the $i$-th allele

:::

:::

::: {.column width="50%"}

::: {.fragment}

<h4>Exercise: calculate the heterozygosity at sites 1, 2 and 5</h4>

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
\begin{align*}
h_1 & = \frac{4}{3} \left(1 - p_T^2 \right) = 0 \\[10pt]
h_2 & = \frac{4}{3} \left(1 - \left(p_C^2 + p_T^2\right) \right) = \frac{4}{3} \left( 1 - \left(\frac{1}{16} + \frac{9}{16}\right)\right) = \frac{1}{2}\\[10pt]
h_5 & = \frac{4}{3} \left(1 - \left(p_A^2 + p_G^2\right) \right) = \frac{4}{3} \left( 1 - \left(\frac{1}{4} + \frac{1}{4}\right)\right) = \frac{2}{3}
\end{align*}
$$

<!-- markdownlint-enable MD013 -->

:::

:::

::::

::: {.notes}

In a randomly mating population, the heterozygosity is equal to the
frequency of heterozygotes. Note however that the definition of
heterozygosity only relies on allele frequencies, which means it can
be applied to populations that are not in Hardy-Weinberg equilibrium,
or to more general variation, such as protein isoforms. It can also be
applied to haploid organisms, like bacteria.

:::

## Describing DNA variation - nucleotide diversity {.smaller}

::: {.dna }

| 1 | 2     | 3 | 4 | 5     | 6 | 7 | 8     | 9 | 10 | 11    | 12 | 13    | 14 | 15    |
|:-:|:-----:|:-:|:-:|:-----:|:-:|:-:|:-----:|:-:|:--:|:-----:|:--:|:-----:|:--:|:-----:|
| T | T     | A | C | A     | A | T | **C** | C | G  | A     | T  | C     | G  | T     |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
| T | **C** | A | C | A     | A | T | G     | C | G  | A     | T  | **G** | G  | **A** |
| T | T     | A | C | **G** | A | T | G     | C | G  | **C** | T  | C     | G  | T     |
|   | *     |   |   | *     |   |   | *     |   |    | *     |    | *     |    | *     |

: {tbl-colwidths="[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]"}

:::

:::: {.columns}

::: {.column width="50%"}

::: {.fragment}

<h4>Nucleotide diversity $\pi$</h4>

The *nucleotide diversity* is the sum of site heterozygosities:

$$
\pi = \sum_{j=1}^S h_j
$$

where $S$ is the number of segregating sites

:::

:::

::: {.column width="50%"}

::: {.fragment}

<h4>Calculate the nucleotide diversity</h4>

:::

::: {.fragment}

Observation: $h_i$ either 1/2 or 2/3 (for sites with
$p_{major}=p_{minor}$).

:::

::: {.fragment}

<!-- markdownlint-disable MD013 -->

$$
\pi = \frac{1}{2} + \frac{2}{3} + \frac{1}{2} + \frac{2}{3} + \frac{1}{2} + \frac{1}{2} = 3\frac{1}{3}
$$

<!-- markdownlint-enable MD013 -->

:::

::: {.fragment}

Often we report $\pi$ per site:

$$
\pi = 3.33/15 = 0.222
$$

:::

:::

::::

::: {.notes}

@hahn_MolecularPopulationGenetics_2019 implicitly assumes we are
looking at DNA polymorphism. The expression actually holds for any
genetic variation at a locus, and is sometimes called the *gene
diversity* [@nei_MolecularEvolutionPhylogenetics_2000, p. 245].

Under the infinite sites model, $E(\pi)=\theta=4N_e\mu$, for which
reason $\pi$ sometimes is called $\theta_\pi$. The measure gives the
average number of pairwise nucleotide differences between two
sequences, so an alternative expression is

$$
\pi = \frac{\sum_{i<j}k_{ij}}{n(n-1)/2}
$$

The latter expression is called the *nucleotide diversity*
[@nei_MolecularEvolutionPhylogenetics_2000 p. 251].

:::

## Alleles as algebraic entities

:::: {.columns}

::: {.column width="50%"}

Recall: **alleles** refer to *different variants* of a sequence at a
locus (genomic position).

::: {.fragment}

Whatever the underlying molecular nature (gene, chromosome,
nucleotide, protein), let's represent a locus by a letter, e.g., $A$
($B$ if two loci, and so on)

:::

::: {.fragment}

If locus has many alleles $1, 2, ...$ , could use indexing $A_1, A_2, ...$.

:::

::: {.fragment}

Will use combination $A$, $a$ for *bi-allelic* loci from now on

:::

:::

::: {.column width="50%"}

::: {.fragment}

::: {.callout-important appearance="simple" icon=false}

### Example: gene coding for flower color

:::::: {.columns}

::::: {.column width="50%"}

[{{< fa solid circle >}}]{style="color: #ff2a2a;"} $A$ red color

{{< fa regular circle >}} $a$ white color

::: {.fragment}

[Punnett square](https://en.wikipedia.org/wiki/Punnett_square)

:::: {style="display: grid; grid-template-columns: auto auto auto;
grid-row-gap: 0px; grid-column-gap: 0px; text-align: center;
align-items: center;"}

:::{}

{{< fa venus >}} \\ {{< fa mars >}}

:::

:::{}

A

:::

:::{}

a

:::

:::{}

A

:::

:::{}

![](assets/images/flower-red.svg){width=75}

:::

:::{}

![](assets/images/flower-pink.svg){width=75}

:::

:::{}

a

:::

:::{}

![](assets/images/flower-pink.svg){width=75}

:::

:::{}

![](assets/images/flower-white.svg){width=75}

:::

::::

:::

:::::

:::::{.column width="5%"}

:::::

::::: {.column width="45%" .fragment}

:::: {style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr;
grid-row-gap: 0px; grid-column-gap: 10px; text-align: center; align-items: center;"}

:::{}

Genotype

:::

:::{}

aa

:::

:::{}

Aa

:::

:::{}

AA

:::

:::{}

Phenotype

:::

:::{}

![](assets/images/flower-white.svg){width=100}

:::

:::{}

![](assets/images/flower-pink.svg){width=100}

:::

:::{}

![](assets/images/flower-red.svg){width=100}

:::

::::

Heterozygote has intermediate color phenotype (pink).

:::::

::::::

:::

:::

:::

::::

::: {.notes}

Until now the examples have been based on nucleotide sequences.
However, much of population genetic theory was developed before the
nature of heredity (DNA) was known. In these early days, an allele
would refer to variant forms of a gene, observed as differences in
phenotypes. Genes, or loci, would be denoted using alphabetic
characters, such as $A$, and allelic types could be referenced with
indices, e.g., $A_1, A_2, ..., A_n$.

To simplify calculations, we often look at one locus and we assume two
alleles, whereby we skip the indices and denote the allelic pairs $A$
and $a$ (although note that notations differs from author to author;
for instance @gillespie_PopulationGeneticsConcise_2004 uses $A_1, A_2$
for bi-allelic loci). For two-locus systems we simply denote the
second allele with $B, b$, and so on.

The example shows a hypothetical locus having two alleles $A$ and $a$
that have phenotypes red and white flower color, and where
heterozygotes are colored pink. The *Punnett square* shows how gamete
combinations form genotypes and their corresponding phenotypes.

:::

## Alleles and frequencies

We will be interested in looking at the dynamics of alleles, i.e., how
their abundances in the population change over time. Therefore we want
to measure the *frequencies* of alleles $A$ and $a$.

:::::: {.columns}

::::: {.column width="55%"}

::: {.fragment fragment-index=1}

::: {.callout-important appearance="simple" icon=false}

### Example

Assume following population ($n=10$, with $n_{AA}=5$, $n_{Aa}=4$,
$n_{aa}=1$):

![](assets/images/flower-red.svg){width=50}
![](assets/images/flower-red.svg){width=50}
![](assets/images/flower-red.svg){width=50}
![](assets/images/flower-red.svg){width=50}
![](assets/images/flower-red.svg){width=50}
![](assets/images/flower-pink.svg){width=50}
![](assets/images/flower-pink.svg){width=50}
![](assets/images/flower-pink.svg){width=50}
![](assets/images/flower-pink.svg){width=50}
![](assets/images/flower-white.svg){width=50}

::: {.fragment fragment-index=2}

Let **$p$** be frequency of $A$ alleles, **$q=1-p$** frequency of $a$ alleles; then

5 $AA$ individuals, 4 $Aa$ individuals $\Rightarrow p=\frac{5\cdot2 +
4\cdot1}{10\cdot2}=\frac{14}{20}=0.7$

and $q=1-p=\frac{6}{20}=0.3$

:::

::: {.fragment fragment-index=3}

Inserting frequencies into **Punnett square** gives expected frequency
of offspring genotypes.

:::

:::

:::

:::::

::::: {.column width="45%"}

:::: {.fragment fragment-index=4}

:::: {style="display: grid; grid-template-columns: auto auto auto;
grid-row-gap: 0px; grid-column-gap: 0px; text-align: center;
align-items: center; font-size: 0.8em;"}

:::{}

{{< fa venus >}} \\ {{< fa mars >}}

:::

:::{}

$A$ ($p=0.7$)

:::

:::{}

$a$ ($q=0.3$)

:::

:::{}

$A$ ($p=0.7$)

:::

:::{}

![](assets/images/flower-red.svg){width=50}

$p\cdot p = 0.49$

:::

:::{}

![](assets/images/flower-pink.svg){width=50}

$p\cdot q = 0.21$

:::

:::{}

$a$ ($q=0.3$)

:::

:::{}

![](assets/images/flower-pink.svg){width=50}

$q\cdot p = 0.21$

:::

:::{}

![](assets/images/flower-white.svg){width=50}

$q\cdot q = 0.09$

:::

::::

::::

::: {.fragment fragment-index=5 .small}

**Expected** allele frequencies after mating: $p=p^2 + pq=0.7$, $q=1-p=0.3$

:::

:::::

::::::

::: {.notes}

Given $n$ diploid individuals, there are $2n$ alleles in the
population. The frequency of allele $A$ is then the homozygote $AA$
times two, plus one times the individuals carrying one $A$.

The Punnett square shows that the expected homozygote frequencies are
$0.49$ and $0.09$ for $AA$ and $aa$, and hence, the frequency of $Aa$
is $1 - 0.49 - 0.09 = 0.42 = 0.21 + 0.21 = 2pq$

:::

## In absence of evolutionary forces alleles are in equilibrium{.smaller}

### The Hardy-Weinberg equilibrium

For a locus, let $A$ and $a$ be two different alleles and let $p$ be
the frequency of the $A$ allele and $q=1-p$ the frequency of the $a$
allele. In the **absence** of **mutation**, **drift**, **migration**,
and other evolutionary processes, the equilibrium state is given by
the **Hardy-Weinberg equilibrium** (**HWE**).

:::: {.columns=center}

::: {.column width="45%"}

|           | $A$ ($p$) | $a$ ($q$) |
|-----------|-----------|-----------|
| $A$ ($p$) | $p^2$     | $pq$      |
| $a$ ($q$) | $qp$      | $q^2$     |

:::

::: {.column width="45%"}

|            |          |          |          |
|------------|----------|----------|----------|
| Genotype:  | $AA$     | $Aa$     | $aa$     |
| Frequency: | $p^2$    | $2pq$    | $q^2$    |
|            | $f_{AA}$ | $f_{Aa}$ | $f_{aa}$ |

:::

::::

Under HWE assumption, neither allele nor genotype frequencies change
over time.

Importantly, we can calculate allele frequencies from genotype
frequencies and vice versa:

$$
p = f_{AA} + \frac{f_{Aa}}{2} = p^2 + pq\\
q = f_{aa} + \frac{f_{Aa}}{2} = q^2 + pq\\
$$

::: {.notes }

Segue: apart from describing the variation via e.g., diversity
measures, we want to model how allele frequencies *change* in time. As
[@gillespie_PopulationGeneticsConcise_2004, preface p. xi] points out,
"While genotype frequencies are easily measured, their change is not"

IOW: describing variation fine, but where does it come from and how
does it change?

If assumptions of HWE hold, we have no change of variation. However,
we **want** to look at **change** of variation and disentangle the
forces that impose change

HWE assumption gives us a way to calculate allele frequencies from
genotype frequencies. How well do these assumptions hold in real data?
See next slide.

:::

## Natural populations do mate randomly?

:::{}

```{r }
#| label: fig-hwe-1000genomes
#| echo: false
#| eval: true
#| out-width: 80%
#| fig-height: 6
#| fig-width: 14
#| fig-align: center
#| fig-cap:
#|     Hardy-Weinberg proportions in 10,000 SNPs on chromosome
#|     22 from three populations based on 1000 genomes data.
#|     For each SNP, genotypes are given as counts (minor/heterozygote/major),
#|     converted to frequencies and plotted on the y-axis. Allele
#|     frequencies are obtained from genotype frequencies and
#|     plotted on the x-axis. Most observations follow HWE proportions.
#|     Deviations from HWE can indicate sample QC issues, or that
#|     there is population structure.
#|     Illustration inspired by @cooplab_PopulationGeneticsCourse_2011.
#|     [{{< fa rectangle-list >}}]({{< var recipes.slides >}}#sec-recipe-slides-hwe)
include_graphics("assets/images/hwe-1000genomes.webp")
```

:::

::: {.notes }

So how do the HWE assumptions hold up in real data? The figure shows
three human populations from the 1000 genomes data, for which 10,000
SNPs have been selected. For each SNP, we know the genotype
frequencies $AA$, $Aa$, $aa$ and can therefore calculate the allele
frequencies for $A$ and $a$ using the equations on the preceding
slide (e.g., $p=p_{AA}+p_{Aa}/2$).

Note that 1000 genomes data have sorted genotype frequencies, so to
produce nice symmetrical plots, half the genotype frequencies have
been reversed (minor/het/major -> major/het/minor).

<!-- markdownlint-disable MD013 -->

See
<https://stackoverflow.com/questions/26587940/ggplot2-different-legend-symbols-for-points-and-lines>
for legend customization.

<!-- markdownlint-enable MD013 -->

:::

## The obsession of population genetics

Population genetics is about [@gillespie_PopulationGeneticsConcise_2004]

1. describing the genetic structure of populations
2. constructing theories on the forces that influence genetic
   variation

::: {.fragment}

:::: {.columns}

::: {.column width="50%"}

Questions to ponder:

- why does variation look the way it does?
- how is variation maintained?
- how does variation change over time ($\Delta p$)?
- what forces shape the genetic structure of *populations*?

:::

::: {.column width="50%" .fragment}

:::: {style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
grid-row-gap: 0px; grid-column-gap: 0px; align-items: center;"}

:::{}

![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}

$$p=0.1$$

:::

:::{}

$$\large\rightarrow$$

:::

:::{}

![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}
![](assets/images/flower-white.svg){width=27}

$$p=0.5$$

:::

:::{}

$$\large\rightarrow$$

:::

:::{}

![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-red.svg){width=27}
![](assets/images/flower-white.svg){width=27}

$$p=0.9$$

:::

::::

:::

::::

:::

::: {.notes }

From HWE: we want to look a the creation, maintenance and loss of
variation and what forces affect it

Goal: describe theory behind evolving populations. This has been an
obsession for a long time, even before DNA was known. We need to get
back to basics.

:::

# Models of populations

:::{}

```{r }
#| label: wright-fisher-drift-models-of-population
#| echo: false
#| eval: true
#| cache: false
#| fig-align: center
#| out-width: 30%
set.seed(1974)
g <- wright_fisher_pop(n = 8, generations = 8, p0 = 3)
ggplot_wf(g, fill = allele) +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

::: {.notes }

Segue: take a step back to the days before the nature of genetic
inheritance was known. First focus on the population.

Goal of lecture is also to understand genetic relationships in the
context of genealogies -> coalescent.

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

::: {.incremental}

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

:::

:::

::: {.column width="50%"}

:::

::::

::: {.notes }

See @hein_GeneGenealogies_2004 for more assumptions. The second
assumption means we can use 2N chromosome interchangeably for haploid
(n=2N) and diploid (n=N) populations.

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero

:::

::: {.column width="50%"}

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

```{r }
#| label: wf-1
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
y_range <- range(V(wf)$y)
ggplot_wf(wf %>% filter(y == 0), y_range = y_range) +
  ggtitle("Starting population")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one

:::

::: {.column width="50%"}

```{r }
#| label: wf-2
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %>%
  filter(y >= 0 & y <= 1) %E>%
  filter(from <= -1) %>%
  ggplot_wf(., y_range = y_range) + ggtitle("Offspring")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.0
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to == 11) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.1
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% c(11, 12)) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.1b
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% c(11:13)) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.2
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:18) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:20) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3-untangled
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:20) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents (untangled)")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-4
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %>%
  filter(y >= 0 & y <= 2) %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0 & y == 1, "b", "a")) %>%
  ggplot_wf(., y_range = y_range, fill = allele) + ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

```{r }
#| label: fig-wright-fisher-model-gganimation
#| echo: false
#| eval: true
#| aniopts: width=1000,controls=all
#| fig-show: animate
#| fig-keep: all
#| fig-cap: Wright-Fisher model
#| fig-format: png
#| out-height: 600px
popsize <- max(V(wf)$x) + 1
generations <- max(V(wf)$y) + 1
for (t in 3:generations) {
  obj <- wf %E>% filter(to <= (t * popsize)) %N>% filter(y >= 0 & y <= t)
  print(ggplot_wf(obj, y_range = y_range) + ggtitle(paste("Generation", t)))

  obj <- wf %N>%
    filter(y >= 0 & y <= t) %>%
    mutate(allele = ifelse(degree(., mode = "out") > 0 & y == (t - 1), "b", "a")) %E>%
    filter(to <= (t * popsize))

  print(ggplot_wf(obj, y_range = y_range, fill = allele) +
    ggtitle(paste("Generation", t)))

  obj <- wf %N>%
    filter(y >= 0 & y <= t) %>%
    mutate(allele = ifelse(degree(., mode = "out") > 0 & y == (t - 1), "b", "a")) %E>%
    filter(to <= ((t + 1) * popsize))

  print(ggplot_wf(obj, y_range = y_range, fill = allele) +
    ggtitle(paste("Generation", t)))
}
```

::: {.notes }

See <https://mikeyharper.uk/animated-plots-with-r/>

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="40%"}

```{r }
#| label: fig-wright-fisher-model-gganimation-last
#| echo: false
#| eval: true
#| fig-cap: |
#|   WF model indicating time
#|   direction from past (top) to present
#|   (bottom).
#| out-width: 80%
#| fig-align: center
x_range <- range(vertex_attr(wf, "x"))
y_range <- range(vertex_attr(wf, "y"))
x1 <- x_range[1] - 0.5
x_range <- c(x1 - 2, x_range[2])
wf %>% ggplot_wf(.) +
  geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - .5, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = 0,
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = 15,
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

::: {.column width="40%"}

::: {.fragment}

```{r}
#| label: fig-wf-model-genealogy
#| echo: false
#| eval: true
#| out-width: 80%
#| fig-align: center
#| fig-cap: "WF model tracing the genealogies of three extant chromosomes"
obj <- wf
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(fill = "white", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3))
```

:::

:::

::::

## The Wright-Fisher sampling model

Let's formalise the sampling process of the Wright-Fisher model^[For a
more extensive treatment, see
@hermisson_MathematicalPopulationGenetics_2017 or @hein2005gene]. We
assume

1. a single locus in a haploid population of size $2N$ (or diploid of
   size $N$ when random mating)
2. no mutation and selection
3. discrete generations

Each generation we sample $2N$ new chromosomes from the previous
generation. The probability of choosing a chromosome $v$ is $1/2N$
(coin flip with probability of success $1/2N$). Since the trials are
independent, and we perform $2N$ trials, the number of offspring $k$
of a given chromosome $v$ is [*binomially
distributed*](https://en.wikipedia.org/wiki/Binomial_distribution)
$\mathrm{Bin}(m, p)$, with parameters $m=2N$ and probability of
success $p=\frac{1}{2N}$.

::: {.notes}

We assume some familiarity with Binomial sampling. For reference, some
mathematical formality follows.

Let $p$ be the probability of heads (=1) of a coin flip, and $q=1-p$
the probability of tails (=0). A coin flip can be modelled by a random
variable (r.v.) $X$ that follows a *Bernoulli distribution*, where
$\mathrm{Pr(}X=1\mathrm{)}=p$, $\mathrm{Pr(}X=0\mathrm{)}=1-p=q$. One
can show (e.g., with transforms such as the [probability-generating
function](https://en.wikipedia.org/wiki/Probability-generating_function))
that a binomially distributed variable $Y\sim Bin(n, p)$ is the sum of
$n$ independent Bernoulli variables $X$ ("Bernoulli trials"), or
$Y=\sum^nX$. In our case, there are $2N$ trials, each with $p=1/2N$.

$$
P(v=k) = {2N\choose k}\left( \frac{1}{2N} \right)^k
\left(1 - \frac{1}{2N} \right)^{(2N - k)}
$$

:::

## Properties of Wright-Fisher sampling{.smaller}

:::: {.columns}

::: {.column width="50%"}

:::{.fragment}

##### The expected number of offspring is one

```{r, engine='tikz', fig.ext='svg' }
#| label: wf-expected-number-of-offspring
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 70%
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1} {
  \foreach \x in {1,2,3,4,5} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
}
\draw[->] (n13) -- (n03);
\draw[->, dotted] (n13) -- (n02);
\draw[->, dotted] (n13) -- (n04);
\node[lab, above of=n13] {$v$};
\end{tikzpicture}
```

:::

:::{.fragment}

##### Poisson approximation for large $N$

```{r, engine='tikz', fig.ext='svg' }
#| label: wf-poisson-approximation-large-n
#| echo: false
#| eval: true
#| fig-align: center
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1} {
  \foreach \x in {1,2,3,4,5,8,9,10} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {6, 6.5, 7} {\node[cdot] at (\x, \y) {};}
}
\draw[->] (n13) -- (n03);
\draw[->] (n13) -- (n02);
\draw[->] (n13) -- (n04);
\node[lab, above of=n13] {$v$};
\node[lab, above of=n11] {$1$};
\node[lab, above of=n110] {$2N$};
\end{tikzpicture}
```

$$
P(v=k) \approx \frac{1}{k!}e^{-k}
$$

:::

:::

::: {.column width="50%"}

:::{.fragment}

##### Prob(pick same parent) = 1/2N{#sec-prob-sequence-pick-same-parent}

```{r, engine="tikz", fig.ext="svg" }
#| label: wf-prob-parents-identical-fig
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: "800"
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{u} = [fill=black];
  \tikzstyle{v} = [fill=gray];
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.3cm, inner sep=0];
\foreach \y in {0, 2} {
  \foreach \x in {1,2,3,4,5,6,7,8,9,12,13,14,15} {
    \node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {10, 10.5, 11} {\node[cdot] at (\x, \y) {};}
}
\node[lab, above of=n21] {1};
\node[lab, above of=n215] {2N};
\node[lab, below of=n03] {u};
\node[lab, below of=n06] {v};
\node[lab, above of=n23] {$p_u=p_v$};
\node[lab, above of=n26] {$p_u \neq p_v$};
\node[lab, above of=n213] {$p_u \neq p_v$};
\draw[->] (n03) -- (n23);
\path[->] (n06) edge node[above right] {$\frac{1}{2N}$} (n23);
\path[->] (n06) edge[dotted] node[right] {$1-\frac{1}{2N}$} (n26);
\path[->] (n06) edge[dotted] node[above left] {$1-\frac{1}{2N}$} (n213);
\end{tikzpicture}
```

:::

:::{.fragment}

##### Time for two sequences to coalesce $\sim 1/2N$

:::: {.columns}

::: {.column width="15%"}

:::

::: {.column width="70%"}

```{r, engine="tikz", fig.ext="svg" }
#| label: wf-two-chrom-find-common-ancestor
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 100%
\begin{tikzpicture}[>=latex,thick]
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{u} = [fill=black];
  \tikzstyle{v} = [fill=gray];
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1,2,3,4,5} {
  \foreach \x in {1,2,3,4,7,8} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {5, 5.5, 6} {\node[cdot] at (\x, \y) {};}
}
\node[lab, above of=n51] {1};
\node[lab, above of=n58] {2N};
\node[lab, below of=n02] {u};
\node[lab, below of=n04] {v};
\draw[->] (n02) -- (n11);
\draw[->] (n11) -- (n22);
\draw[->] (n22) -- (n32);
\draw[->] (n32) -- (n43);
\draw[->] (n43) -- (n53);
\draw[->] (n04) -- (n14);
\draw[->] (n14) -- (n23);
\draw[->] (n23) -- (n33);
\draw[->] (n33) -- (n44);
\draw[->] (n44) -- (n53);

\node at ($(n01) !.5! (n11) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n11) !.5! (n21) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n21) !.5! (n31) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n31) !.5! (n41) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n41) !.5! (n51) - (1, 0)$) {$\frac{1}{2N}$};
\end{tikzpicture}
```

:::

::: {.column width="15%"}

:::

::::

:::

:::

::::

::: {.notes}

Many of the results above follow from standard results in probability
theory and are provided here in brevity for reference to the
interested reader. The details are not necessary to understand in
detail.

#### Expected number of offspring

The expected value of a $\mathrm{Bin}(m,p)$ (binomially distributed)
variable with parameters $m=2N$ and $p=\frac{1}{2N}$ is $mp$, hence:

$$
E(v) = mp = 2N\frac{1}{2N} = 1
$$

#### Poisson approximation

When $2N$ large it holds that the probability that sequence $v$ has
$k$ offspring is

$$
P(v=k) \approx \frac{1}{k!}e^{-k}
$$

Since $P(v=0) = e^{-1} \approx 0.37$, a fraction 0.37 of sequences lack
descendants

#### Probability that two sequences pick same parent

Let $u$ and $v$ be two sequences. Pick a parent $p_u$ of $u$. Then the
probability that $v$ picks the same parent is (solid lines)

$$
P(p_u=p_v) = \frac{1}{2N}
$$

The probability that they pick different parents is

$$
P(p_u \neq p_v) = 1 - \frac{1}{2N}
$$

##### Time for two sequences to coalescent

Time for two sequences $u$ and $v$ to find common ancestor
distributed as $(1 - \frac{1}{2N})^{j-1}\frac{1}{2N}$ ($j-1$ failures
followed by success). This is the [geometric
distribution](https://en.wikipedia.org/wiki/Geometric_distribution)
$Ge(p)$, with parameter $p=\frac{1}{2N}$, and expected value
$\frac{1}{p}={2N}$. That is, the **expected number of generations for
two sequences to find a common ancestor (i.e., coalesce) is $2N$
generations**.

Since a large fraction of genes lack descendants, very quickly
(compared to 2N) a population will descend from a small proportion of
genes.

Derivation of average time to having same parent (i.e., coalescence)
requires knowledge of geometric distribution. The probability that the
genes find common parent $j$ generations ago is

$$
(1-\frac{1}{2N})^{(j-1)}\frac{1}{2N}
$$

due to independence between generations. This is the geometric
distribution $Ge(p)$ with $p=1/2N$, which has expected value $1/p$,
i.e., 2N in this case.

:::

# Origin and change of variation

:::: {style="display: grid; grid-template-columns: 300px 200px 200px;
grid-row-gap: 0px; grid-column-gap: 100px;"}

<div>&nbsp;</div>

:::{.circular-image}

Mutation

![](../pgip/assets/images/mutation.webp)

:::

:::{.circular-image}

Selection

![](../pgip/assets/images/finches.webp)

:::

<div>&nbsp;</div>

:::{.circular-image}

Recombination

![](../pgip/assets/images/recombination.webp)

:::

:::{.circular-image}

Drift

![](../pgip/assets/images/genetic-drift.webp)

:::

::::

## Wright-Fisher model with alleles {.smaller}

:::: {.columns .compact}

::: {.column width="35%" }

```{r }
#| label: wright-fisher-drift-0.3-1
#| echo: false
#| eval: true
#| cache: false
set.seed(1974)
g <- wright_fisher_pop(n = 10, generations = 16, p0 = 3)
ggplot_wf(g, fill = allele) + ggtitle("Allele fixation") +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

::: {.column width="35%" .fragment}

```{r }
#| label: wright-fisher-drift-0.3-2
#| echo: false
#| eval: true
#| cache: false
set.seed(2014)
g <- wright_fisher_pop(n = 10, generations = 16, p0 = 0.3)
ggplot_wf(g, fill = allele) + ggtitle("Allele loss") +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

:::{.column width=30% .fragment}

Alleles can randomly *fix* or be *lost* through process called
**genetic drift**

:::

Wright-Fisher model showing the evolution of population of 10 genes
over 16 generations. Allele variants are shown in white and black.
Starting frequency black variant is 0.3.

::::

::: {.notes }

(To avoid confusion: previously black was used to indicate parent,
here black/white will refer to different alleles)

Enter allelic variants; we are looking at two alleles

Important: the fate of any allele under drift is to be **lost** or
**fixed**, which ultimately means variation is **lost** (decays) with
drift

:::

## Binomial process models allele sampling {.smaller}

```{r }
#| label: allele-sampling-model
#| echo: false
#| eval: true
#| cache: false
#| out-width: 60%
#| fig-height: 3
#| fig-width: 12
#| fig-align: center
set.seed(901)
wf <- wright_fisher_pop(n = 20, generations = 2, p0=0.3)
y_range <- range(V(wf)$y)
ggplot_wf(wf, fill=allele)
```

:::: {.columns .fragment}

::: {.column width="50%"}

We assume two alleles $A$, $a$, each with $i$ and $j=2N-i$ copies in
generation $t$.

:::

::: {.column width="50%"}

:::: {style="display: grid; grid-template-columns: 1fr 1fr;
grid-row-gap: 0px; grid-column-gap: 0px; align-items: center;"}

:::{}

![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-white.svg){width=20}
![](assets/images/flower-white.svg){width=20}

:::

:::{}

$i=8$, $j=2\cdot 6-8=4$

:::

::::

:::

::::

:::: {.columns .fragment}

::: {.column width="50%"}

Let $p_t=i/2N$ be the *frequency* of $A$ in generation $t$, and
$q_t=1-p_t$ the frequency of $a$.

:::

::: {.column width="50%"}

:::: {style="display: grid; grid-template-columns: 1fr 1fr;
grid-row-gap: 0px; grid-column-gap: 0px;"}

:::{}

![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-white.svg){width=20}
![](assets/images/flower-white.svg){width=20}

$p_t = 8/12$

:::

:::{}

![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-red.svg){width=20}
![](assets/images/flower-white.svg){width=20}
![](assets/images/flower-white.svg){width=20}
![](assets/images/flower-white.svg){width=20}
![](assets/images/flower-white.svg){width=20}

$p_{t+1} = 4/12$

:::

::::

:::

::::

::: {.fragment}

Prob($k$ $A$ alleles in next generation) is $\mathsf{Bin}(2N,
\frac{i}{2N})$

:::

::: {.notes }

A more formal mathematical description goes as follows:

The sampling model for next generation $t+1$, *given* $i$ $A$ alleles
in generation $t$, is

$$
p_{t+1} = P(v_A=k) = {2N\choose k}\left( \frac{i}{2N} \right)^k
\left(1 - \frac{i}{2N} \right)^{(2N - k)} = \mathsf{Bin}(2N, \frac{i}{2N})
$$

NB: we here slightly change notation, with $p_{t+1} = P(X=k)$. Also,
we have omitted an index $i$ in the expressions of $p$. The
probability of observing $k$ $A$ alleles in generation $t+1$ will of
course depend on the number $i$ $A$ alleles in the previous
generation.

:::

## Genetic drift

:::: {.columns}

::: {.column width="50%"}

To capture dynamics, follow allele frequency trajectory ($p_t$) as
function of time.

::: {.smallr}

```{r code=readLines("../../src/R/pgip/R/wright_fisher.R")}
#| label: wright-fisher-source
#| echo: true
#| eval: false
```

```{r }
#| label: wright-fisher-plot
#| echo: true
#| eval: false
# Example simulation and plot
set.seed(1223)
generations <- 100
n <- 100 # NB: haploid population size!
plot(1:generations,
     wright_fisher(0.5, n, generations),
     type="l", ylab="frequency",
     xlab="generation", ylim=c(0, 1))
```

:::

:::

::: {.column width="50%"}

::: {.fragment}

```{r }
#| label: genetic-drift-example
#| echo: false
#| eval: true
#| cache: false
set.seed(1223)
n_reps <- 50
n_gen <- 100
conditions <- 4
p0 <- rep(c(0.01, 0.1, 0.5, 0.8), each = conditions)
N <- rep(c(50, 100, 1000, 5000), conditions)
sample <- rep(seq(1, n_reps), length(N))
p0_long <- rep(p0, each = n_reps)
N_long <- rep(N, each = n_reps)

wf <- mapply(wright_fisher, p0_long, N_long, n_gen, SIMPLIFY = FALSE)
wf <- data.frame(
  frequency = unlist(wf), N = rep(N_long, each = n_gen),
  generation = seq(1, n_gen), sample = rep(sample, each = n_gen),
  p0 = rep(p0_long, each = n_gen)
)
wf$N <- factor(wf$N)
wf$sample <- factor(wf$sample)
```

```{r }
#| label: fig-genetic-drift-N-10
#| echo: false
#| eval: true
#| fig-show: animate
#| fig-format: png
#| fig-keep: all
#| out-width: 80%
#| fig-height: 6
#| fig-width: 6
#| fig-cap:
#|    Genetic drift for different haploid(!) population sizes,
#|    starting frequency $p_0$=0.5. Note dependency of variance
#|    on population size N.
ggplot(
  subset(wf, wf$sample == 1 & wf$p0 == 0.5),
  aes(x = generation, y = frequency)
) +
  geom_line(size = 1) +
  xlim(1, 100) +
  ylim(0, 1) +
  facet_wrap(. ~ N) +
  transition_reveal(generation)
```

:::

:::

::::

::: {.notes }

Mention *neutral* here as this is how alleles behave under
drift: like gas particle diffusing up and down. Allele is eventually either fixed or lost.

:::

## Genetic drift

:::: {.columns}

::: {.column width="50%"}

<!-- markdownlint-disable MD013 -->

```{r }
#| label: fig-genetic-drift-many-repetitions
#| echo: false
#| eval: true
#| fig-height: 8
#| fig-width: 12
#| out-height: "380"
#| out-width: "560"
#| fig-cap: |
#|   Genetic drift for different combinations of starting
#|   frequency and population size for n=50 repetitions per parameter
#|   combination. Note how variation and time to fixation depends on
#|   population size and starting frequency.
ggplot(wf, aes(x = generation, y = frequency, group = sample)) +
  geom_line() +
  xlim(1, 100) +
  ylim(0, 1) +
  facet_grid(N ~ p0)
```

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="50%"}

::: {.incremental}

- fate of allele: fixation or loss $\rightarrow$ eventually loss of
  variation
- **probability of fixation $\pi(p)=p$**, where $p$ is the *current*
  frequency
- rate of drift (loss of variation) $\propto \frac{1}{2N}$

:::

::: {.fragment}

::: {.center}

```{r, engine='tikz', fig.ext="svg" }
#| label: gas-particle-drift
#| echo: false
#| eval: true
#| out-height: "200"
#| fig-align: center
\begin{tikzpicture}
\node[circle, fill=black] (n) {};
\node[above of=n] (drift_up) {};
\node[below of=n] (drift_down) {};
\draw[->, >=latex] (n) -- node[right] {drift} (drift_down);
\draw[->, >=latex] (n) -- node[right] {drift} (drift_up);
\end{tikzpicture}
```

:::

:::

:::

::::

::: {.notes }

Simplifying assumptions -> rate of drift $\propto \frac{1}{N}$
($\frac{1}{2N}$ in our treatment) [@leffler_RevisitingOldRiddle_2012]

In reality population fluctuates and therefore Ne is substituted for
N. Larger Ne -> smaller fluctuation in allele frequency (as evidenced
in plots) -> maintain larger genetic diversity

Drift can be thought of as a force acting on a buoyant gas particle
floating up and down at random.

:::

## Allele frequency distribution for N=1 {.smaller}

Instead of looking at frequencies let's switch to distributions of
alleles for **one** individual, one locus. Then there are three
possible genotypes (**states**) $aa$, $aA$, and $AA$. Let $n=0,1,2$ be
an integer corresponding to each genotype (i.e., it counts the number
of $A$ alleles).

Assume individual mates with itself at random(!) starting in either of
the three states. How does distribution evolve?

:::: {.columns .fragment fragment-index=1}

::: {.column width="10%"}

t=0

:::

::: {.column width="30%"}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-aa
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,1) (1,0) (2, 0) (3, 0)};
\node[label] (aa) at (0.5, 1.8) {aa};
\node[label] (Aa) at (1.5, 1.8) {Aa};
\node[label] (AA) at (2.5, 1.8) {AA};
\node[label] (0) at (0.5, 1.4) {0};
\node[label] (1) at (1.5, 1.4) {1};
\node[label] (2) at (2.5, 1.4) {2};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

::: {.column width="30%"}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-aA
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,0) (1,1) (2, 0) (3, 0)};
\node[label] (aa) at (0.5, 1.8) {aa};
\node[label] (aA) at (1.5, 1.8) {aA};
\node[label] (AA) at (2.5, 1.8) {AA};
\node[label] (0) at (0.5, 1.4) {0};
\node[label] (1) at (1.5, 1.4) {1};
\node[label] (2) at (2.5, 1.4) {2};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

::: {.column width="30%"}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-AA
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,0) (1,0) (2, 1) (3, 1)};
\node[label] (aa) at (0.5, 1.8) {aa};
\node[label] (aA) at (1.5, 1.8) {aA};
\node[label] (AA) at (2.5, 1.8) {AA};
\node[label] (0) at (0.5, 1.4) {0};
\node[label] (1) at (1.5, 1.4) {1};
\node[label] (2) at (2.5, 1.4) {2};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

::::

:::::{.translatey50}

:::: {.columns}

::: {.column width="10%"}

::: {.fragment fragment-index=2}

t=1

:::

:::

::: {.column width="30%"}

::: {.fragment fragment-index=2}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-aa-1
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,1) (1,0) (2, 0) (3, 0)};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

:::

::: {.column width="30%"}

::: {.fragment fragment-index=4}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-aA-1
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,0.25) (1,0.5) (2, 0.25) (3, 0.25)};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

:::

::: {.column width="30%"}

::: {.fragment fragment-index=3}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-AA-1
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,0) (1,0) (2, 1) (3, 1)};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

:::

::::

:::::

:::::{.translatey100}

:::: {.columns}

::: {.column width="10%"}

::: {.fragment fragment-index=5}

t=2

:::

:::

::: {.column width="30%"}

:::

::: {.column width="30%"}

::: {.fragment fragment-index=5}

```{r, engine='tikz', fig.ext="svg"}
#| label: tikz-afd-aA-2
#| echo: false
#| eval: true
#| out-width: 200px
\begin{tikzpicture}[ybar interval]
\tikzstyle{tick}=[font=\scriptsize];
\tikzstyle{label}=[font=\small];
  \draw[fill=black, draw=black]
plot coordinates{(0,0.375) (1,0.25) (2, 0.375) (3, 0.25)};
 \draw[->] (0, -0.2) -- (0, 1.2);
\draw (-0.1, 1) -- (0.1, 1);
\draw (-0.1, 0) -- (0.1, 0);
\node[tick] at (-0.4, 1) {1};
\node[tick] at (-0.4, 0) {0};
\end{tikzpicture}
```

:::

:::

::: {.column width="30%"}

:::

::::

:::::

::: {.notes}

Example from [@gillespie_PopulationGeneticsConcise_2004, p. 24]. We
look at a single hermaphroditic individual that mates with itself at
random. For each generation, given a genotype distribution, we
calculate the outcome for the next generation. For instance, starting
out in state 0 (only $aa$ genotypes, hence only $a$ alleles), we can
only produce new $aa$ genotypes and will therefore never leave
state 0. The same holds for state 2. These states are *absorbing
states*.

Starting from state 1 ($aA$) we can get $aa$ genotype with 25%
probability, since the probability of picking one $a$ is 50%, and we
perform two draws. Similarly, we get $AA$ with 25% probability,
leaving 50% to $aA$.

In the next generation, the $aA$ genotype frequency is 0.5, to be
split in fractions 0.25, 0.5, 0.25 as before, and so on.

To study the system we therefore need to enumerate the probabilistic
outcomes from each state ($aa$ -> 1, 0, 0, $aA$ -> 0.25, 0.5, 0.25,
$AA$ <- 0, 0, 1). To get the state in next generation, we multiply the
current distribution with these outcomes. The next slide gives
Kimura's example for the case where we have N=10 chromosomes.

:::

## Probability distributions of allele frequencies {.smaller}

```{r }
#| label: allele-frequency-histogram
#| echo: false
#| eval: true
n <- 10
x <- vector(mode="numeric", length=n + 1)
# Start with n major = n minor
n_a <- ceiling(length(x)/2)
x[n_a] <- 1
class <- c("absorbing", rep("normal", n - 1), "absorbing")
# Make transition matrix
P <- do.call("rbind", lapply(0:n, function(i) {dbinom(0:n, n, i/n)}))

plot_drift_histogram <- function(t, P) {
  data <- t(x %*% (P%^%t))
  xlabels <- unlist(lapply(0:n, function(x) {
    sprintf("frac(%i, %i)", x, n)
  }))
  p <- data.frame(n=0:n, class=class, obs=data) %>%
    ggplot(aes(y=obs, x=n, fill=class)) +
    geom_bar(stat="identity", color="black", width=1) +
    xlab("") + ylab("") +
    annotate("text", label = paste("t =", t), fontface="italic",
             x = n/2, y = 1.2*max(data), size = 10) +
    scale_fill_manual(values=list("absorbing"="black", "normal"="white")) +
    theme(legend.position="none",
          axis.text.y = element_text(size=16),
          axis.text.x = element_text(size=16, angle=0, hjust=0.5, vjust=0)) +
    scale_x_continuous(
        breaks=0:n,
        labels=do.call(c, lapply(xlabels, function(l) {parse(text=l)}))) +
    ylim(c(0, 1.3*max(data)))
  p
}
```

:::: {.columns}

::: {.column width="40%"}

```{r }
#| label: fig-allele-frequency-histogram-plot
#| echo: false
#| eval: true
#| out-width: 100%
#| fig-width: 12
#| fig-height: 8
#| fig-cap: |
#|     Histogram showing the course of change of the allele
#|     frequency distribution with time [@kimura_1983, Fig. 3.4].
#|     When N large ($\gtrsim 100$) histogram can be approximated
#|     by continuous distribution (diffusion theory). Try recipe
#|     [{{< fa rectangle-list >}}]({{< var recipes.slides
#|     >}}#sec-recipe-slides-allele-frequency-distribution)
#|     for different values of N.
grid.arrange(
    plot_drift_histogram(t=1, P=P),
    plot_drift_histogram(t=5, P=P),
    plot_drift_histogram(t=10, P=P),
    plot_drift_histogram(t=20, P=P),
    ncol=2)
```

:::

::: {.column width="60%"}

```{r }
#| label: fig-buri-table-14
#| echo: false
#| eval: true
#| out-width: 60%
#| fig-width: 12
#| fig-height: 10
#| fig-align: center
#| fig-cap: |
#|    Frequency distributions of the brown eye ($bw^{75}$)
#|    allele in replicate experimental populations ($n\sim 100$)
#|    of *Drosophila melanogaster* (8 {{< fa venus >}},
#|    8 {{< fa mars >}}) [@buri_GeneFrequencySmall_1956]
data <- read.csv("assets/data/buri-table14.csv", header=TRUE, fill=0)
colnames(data)[3:35] <- as.character(0:32)
data <- data %>% replace(., is.na(.), 0)
data$`32` <- data$`32` + data$Total.fixed.bw.75
data$`0` <- data$`0` + data$Total.fixed.bw
plot_buri <- function(t, xaxis=FALSE, yaxis=FALSE, title=TRUE) {
  labels <- lapply(0:32, function(x) {
    ""
  })
  names(labels) <- as.character(0:32)
  labels$`0` <- 0
  labels$`32` <- 1
  p <- ggplot(stack(subset(data[2:20,c(1, 2:36)], Generation==t)[ , 3:35]),
              aes(x=ind, y=values)) +
    geom_bar(stat="identity") +
    theme(legend.position="none",
          axis.ticks=element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          plot.margin = unit(c(0, 0, 0, 0), "null"),
          panel.spacing = unit(c(0, 0, 0, 0), "null")) +
    ylab("") + xlab("") + ylim(0, 30)
  if (title) {
    p <- p + annotate("text", label = paste("t =", t), fontface="italic",
                      x = 2, y = 28, size = 8)
  }
  if (xaxis)  {
    p <- p + scale_x_discrete(breaks=0:32, labels=labels) +
      xlab("Frequency") +
      theme(axis.text.x = element_text(size=16, angle=0,
                                       hjust=0.5, vjust=0))
  }
  if (yaxis) {
    p <- p + ylab("Count") +
      theme(axis.text.y = element_text(size=16))
  }
  p
}
grid.arrange(
    plot_buri(1),# plot_buri(2), plot_buri(3),
    plot_buri(5),# plot_buri(5), plot_buri(6),
    plot_buri(10),# plot_buri(8), plot_buri(9),
    plot_buri(15),# plot_buri(11), plot_buri(12),
    plot_buri(19),
    ncol=1, padding=0
)
```

:::

::::

::: {.fragment}

Mathematical treatment of drift can become complicated: easier to
study dynamics of *heterozygosity*

:::

::: {.notes}

Kimura's plot illustrates the allelic frequency distribution of
replicate populations each consisting of N=10 sequences. There are two
allelic types. The x axis corresponds to the proportion of populations
in a given state (e.g., the y value for x=3/10 corresponds to the
proportion of populations with 3 alleles of one type and 7 of the
other). At $t=0$ all populations are in state 5/10.

Kimura's plot is very instructive and students are encouraged to test
the recipe code, increasing the number of states incrementally. For
large enough N, the histograms can be approximated by continuous
distributions. This observation led Kimura (even though diffusion
equations were originally introduced to genetics by Fisher in 1922) to
apply diffusion theory to obtain probability densities of allele
frequencies, leading in turn to compact expressions of fixation
probabilities, expected ages of alleles, and more. A treatment of
diffusion theory is outside the scope of this course; the interested
reader can consult e.g., [@ewens_MathematicalPopulationGenetics_2004].

The Buri experiment is an empirical demonstration of Kimura's plot.

On the sampling model, [@charlesworth_ElementsEvolutionaryGenetics_2010, p. 231] says:

> It is, however, impossible to write down a simple algebraic
> expression for P, even without selection and mutation. [The
> equation] is useful for obtaining numerical results for relatively
> small populations, but becomes computationally demanding when N
> becomes very large.

:::

## Heterozygosity dynamics{.smaller}

:::: {.columns}

::: {.column width="50%"}

```{r, engine='tikz', fig.ext="svg" }
#| label: fig-identity-by-state-and-descent
#| echo: false
#| eval: true
#| out-width: 70%
#| fig-cap:
#|     Illustration of identity by descent (IBD) and state (IBS).
#|     Alleles in generation $n$ are IBD but not IBS.
\begin{tikzpicture}
\node (n_2) {$n-2$};
\node[right of=n_2] (nl0) {};
\node[right of=nl0] (n0) {\ttfamily-aac-};
\node[right of=n0] (nr0) {};
\node[below of=nl0,anchor=north] (n1) {\ttfamily-aac-};
\node[below of=nr0,anchor=north] (n2) {\ttfamily-aac-};
  \node[below of=n1,anchor=north] (n3) {\ttfamily-aac-};
  \node[below of=n2,anchor=north] (n4) {\ttfamily-aag-};
  \node[left of=n1] (nm1) {$n - 1$};
  \node[left of=n3] {$n$};
  \draw[->] (n0) -- (n1);
  \draw[->] (n0) -- (n2);
  \draw[->] (n1) -- (n3);
  \draw[->] (n2) -- (n4);
\end{tikzpicture}
```

:::

::: {.column width="50%"}

Let $\mathcal{H}_t$ be the probability that two alleles are
**different by state**. One can show that the time course evolution of
$\mathcal{H}_t$ in a randomly mating population consisting of $N$
diploid hermaphroditic individuals is

$$
\mathcal{H}_t = \mathcal{H}_0 \left( 1 - \frac{1}{2N} \right)^t
$$

Important consequence: heterozygosity in WF population lost at rate
$1/2N$.

:::

::::

::: {.notes }

Alleles in generation $n$ are IDB but not IBS

Motivation: mathematical description of genetic drift complicated for
populations with more than one individual. Easier to study the
evolution of heterozygosity.

Equation presented without details. Derivation in
[@gillespie_PopulationGeneticsConcise_2004, pp. 25-27] starts from
G=probability that two alleles are IBS

:::

## Heterozygosity dynamics {.smaller}

:::: {.columns}

::: {.column width="40%"}

```{r }
#| label: fig-gillespie-2.4
#| echo: false
#| eval: true
#| fig-cap:
#|    Plot of $\mathcal{H}_t$ illustrating dependency
#|    on population size
#| out-width: 90%
het_t <- function(N=1, t=0:100, H0=1) {
  H0 * (1 - 1/(2*N))^t
}
tmax <- 100
t <- 0:tmax
data <- data.frame(
    population_size = c(
        rep(1, length(t)),
        rep(10, length(t)),
        rep(100, length(t)),
        rep(1e6, length(t))),
    het = c(het_t(N=1), het_t(N=10), het_t(N=100), het_t(N=1e6)),
    tn = rep(t, 4)
)
ggplot(data, aes(x=tn, y=het, shape=factor(population_size))) +
  geom_point(size=3) + geom_line() + xlab("generation") +
  ylab("heterozygosity") + guides(shape=guide_legend(title="Size")) +
  theme(text=element_text(size=28))
```

:::

::: {.column width="60%"}

::: {.fragment}

:::: {.columns}

::: {.column width="60%"}

```{r }
#| label: fig-black-footed-ferret
#| echo: false
#| eval: true
#| out-width: 90%
#| fig-cap: Heterozygosity in black-footed ferret
#|     [@wisely_GeneticDiversityFitness_2002].
#|     Example from @grahamcoop_NotesPopulationGenetics_2020, Fig. 4.5
# cf: https://github.com/cooplab/popgen-notes/blob/master/Journal_figs/genetic_drift/black_footed_ferrets/black-footed-ferrets_He.csv
data <- data.frame(date=c(1891, 1972, 1985, 1986),
                   He=c(0.231284916, 0.210335196,
                        0.101396648, 0.067877095),
                   N=c("N>10k", "N=62", "N=40", "N=7")
                   )
ggplot(data, aes(x=date, y=He, label=N)) +
  geom_line(size=1.2) + geom_point(size=4) +
  xlab("year") + ylab("heterozygosity") +
  geom_text(nudge_y=0.005, nudge_x=c(12, 12, 12, 10), size=12) +
  theme(text=element_text(size=30)) + xlim(1880, 2005)
```

:::

::: {.column width="40%"}

![](assets/images/ferret.svg){width=40%}

Example of how rapid decline in population size can affect
heterozygosity.

::: {.fragment}

Population size influences genetic diversity!

:::

::: {.fragment}

However, *census* population size not (always) the correct measure.

:::

:::

::::

:::

:::

::::

::: {.notes}

Dependency on population size: for large enough populations the
decline will be **very** slow (drift speed ~ 1/2N)

Practical example shows loss of heterozygosity tell-tale signature of
population decline; conversely, **not** easy to show population
decline in large populations (e.g., marine species with large $N_e$)
using heterozygosity as measure

[@barton2007evolution, p. 369] "The relation between genetic diversity
and population size is difficult to discern, in part, because it is
extremely hard to estimate the numbers of most species and because the
number that matters is an average back into the distant past"(!)

From [@grahamcoop_NotesPopulationGenetics_2020, p. 64]

> To see how a decline in population size can affect levels of het-
> erozygosity, let’s consider the case of black-footed ferrets
> (Mustela nigripes). The black-footed ferret population has declined
> dramatically through the twentieth century due to destruction of
> their habitat and sylvatic plague. In 1979, when the last known
> black-footed ferret died in captivity, they were thought to be
> extinct. In 1981, a very small wild population was rediscovered (40
> individuals), but in 1985 this population suffered a number of
> disease outbreaks. At that point of the 18 remaining wild
> individuals were brought into captivity, 7 of which reproduced.
> Thanks to intense captive breeding efforts and conservation work, a
> wild population of over 300 individuals has been established since.
> However, because all of these individuals are descended from those 7
> individuals who survived the bottleneck, diversity levels remain
> low. Wisely et al. measured heterozygosity at a number of
> microsatellites in individuals from museum collections, showing the
> sharp drop in diversity as population sizes crashed (see Figure
> 4.5).

Segue: population size important; however, *census* population size is
not always the measure we want when relating to genetic diversity

:::

## Effective population size

Assumptions underlying Wright-Fisher model seldom fulfilled for natural populations. In particular

- non-random mating (population structure)
- fluctuations of population census size

Therefore, magnitude of drift experienced by a population different
from that predicted by population size

Technically correct definition (but see @waples_WhatNeAnyway_2022, @waples_IdiotsGuideEffective_2025):

> $N_e$ is the size of an ideal population that would experience the
> same rate of genetic drift as the population in question.

::: {.notes }

ideal population: discrete generations with random mating, no
evolutionary forces besides drift, no selective advantages

:::

## Mutation

:::: {.columns}

::: {.column width="30%"}

<table>
<tr>
<td><div style="transform: translate(50px, 0px);"><i class="fa-solid fa-bolt fa-2x fa-rotate-90"></i></div></td>
<td><div style="transform: translate(0px, 40px);"><i class="fa-solid fa-dna fa-5x"></i></div></td>
</tr>
</table>

:::

::: {.column width="70%"}

```{r }
#| label: allele-sampling-model-mutation
#| echo: false
#| eval: true
#| cache: false
#| fig-height: 3
#| fig-width: 12
#| fig-align: center
set.seed(1212)
wf <- wright_fisher_pop(n = 6, generations = 2, mu = 0.02)
ggplot_wf(wf, fill = allele, size=6) +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

::::

::: {.fragment}

:::: {.columns}

::: {.column width="70%"}

<!-- markdownlint-disable MD013 -->

```{r, engine='tikz', fig.ext="svg" }
#| label: mutation-models
#| echo: false
#| eval: true
\usetikzlibrary{fit,decorations.pathreplacing}

\begin{tikzpicture}[
  every matrix/.style={matrix of nodes, ampersand replacement=\&,
    nodes in empty cells},
  every node/.style={text height=1.5ex},
  ]
\tikzstyle{sequence} = [black, font=\sffamily, column sep={.5cm,between origins}]
  \matrix(seq)[sequence] at (0,0)
  {
    T \& T \& A \& C \& A \& A \& T \& C \& C \& G \& A \& T \& C \& G \& C\\
    T \& T \& A \& C \& G \& A \& T \& G \& C \& G \& C \& T \& C \& G \& C\\
    T \& C \& A \& C \& A \& A \& T \& G \& C \& G \& A \& T \& G \& G \& A\\
     T \& T \& A \& C \& G \& A \& T \& G \& C \& G \& C \& T \& C \& G \& T\\
  };
\node[fit={(seq-1-2.north west) (seq-4-2.south east)}, inner sep=0, draw=black]{};
\node[fit={(seq-1-15.north west) (seq-4-15.south east)}, inner sep=0, draw=black]{};
\node[above of=seq-1-2, node distance=1.2cm] (two-allele) {Two-allele model};
\draw (seq-1-2.north) -- (two-allele);
\node[above of=seq-1-15, node distance=1.2cm] (finite) {Finite sites model};
\draw (seq-1-15.north) -- (finite);
\draw[decorate,decoration={brace,raise=0.2cm}] (seq-1-15.north east) -- (seq-4-15.south east);
\node at ($(seq-3-15) !.5! (seq-2-15)$) (seq-right) {};
\node[anchor=west, text width=1cm, right of=seq-right, node distance=1.2cm] (infinite-alleles) {Inifinite alleles model};
\node at ($(seq-4-1) !.5! (seq-4-15)$) (seq-low) {};
\draw[decorate,decoration={brace,mirror,raise=0.2cm}] (seq-4-1.south west) -- (seq-4-15.south east);
\node[below of=seq-low, node distance=.8cm] (infinite-sites) {Inifinite sites model};
\end{tikzpicture}
```

<!-- markdownlint-enable MD013 -->

:::

::: {.column width="30%"}

Two-allele
: Derive popgen stats

Finite sites
: Recurrent mutations

Infinite alleles
: Protein electrophoresis

Inifinite sites
: DNA sequences

:::

::::

:::

::: {.notes }

Mutations are generated randomly as changes in DNA. In WF model will
be highlighted in black. We assume mutations are described by a
Poisson process with rate $\mu$ (per generation).

The mutation models are:

- two-allele model: used to derive popgen statistics
- finite sites model: recurrent mutations may occur, an assumption
  that is often omitted to facilitate calculations (e.g., coalescent)
- inifinite alleles model: every mutation leads to new allele (e.g.,
  protein electrophoresis)
- infinite sites model: model commonly used for long DNA sequences

Additional model not presented here is the stepwise mutation model
(mainly used to model repeats):

<!-- markdownlint-disable MD013 -->

```{r, engine='tikz', fig.ext='svg' }
#| label: stepwise-mutation-model
#| echo: false
#| eval: true
#| out-width: 1000px
\begin{tikzpicture}[
  every matrix/.style={matrix of nodes, ampersand replacement=\&,
    nodes in empty cells},
  every node/.style={text height=2ex},
  ]
  \tikzstyle{sequence} = [black, font=\sffamily, column sep={1.5cm,between origins},row sep={.7cm}]
  \matrix(seq)[sequence] at (0,0)
  {
$\mathsf{A}_{i-3}$ \&  $\mathsf{A}_{i-2}$ \&  $\mathsf{A}_{i-1}$ \& $\mathsf{A}_{i}$ \&  $\mathsf{A}_{i+1}$ \&  $\mathsf{A}_{i+2}$ \& $\mathsf{A}_{i+3}$ \\
  \&   \&  \&   \&   \&  \&  \\
  };
\draw[<->] (seq-1-1) -- (seq-1-2);
\draw[<->] (seq-1-2) -- (seq-1-3);
\draw[<->] (seq-1-3) -- (seq-1-4);
\draw[<->] (seq-1-4) -- (seq-1-5);
\draw[<->] (seq-1-5) -- (seq-1-6);
\draw[<->] (seq-1-6) -- (seq-1-7);
\node[left of=seq-1-1, node distance=0.7cm] {...};
\node[right of=seq-1-7, node distance=0.7cm] {...};
\draw[thick] (seq-2-1.south) -- (seq-2-1.north)
(seq-2-2.south) -- (seq-2-2.north)
(seq-2-3.south) -- (seq-2-3.north)
(seq-2-4.south) -- (seq-2-4.north)
(seq-2-5.south) -- (seq-2-5.north)
(seq-2-6.south) -- (seq-2-6.north)
(seq-2-7.south) -- (seq-2-7.north);

\draw[thick] (seq-2-1.west) -- (seq-2-7.east);
\node[above of=seq-1-4] {Stepwise mutation model};
\end{tikzpicture}
```

<!-- markdownlint-enable MD013 -->

:::

## Mutation and drift

:::: {.columns}

::: {.column width="60%"}

Genetic drift "moves" frequencies to the point that variation is lost
via allele fixation or loss. New variation is introduced through
**mutation**. We typically assume mutations are described by a
[Poisson process](https://en.wikipedia.org/wiki/Poisson_point_process)
with rate $\mu$ (per generation).

::: {.fragment}

The **mutation rate** is denoted $\mu$, and the **population scaled**
mutation rate is $2N_e\mu$ for haploid populations, $4N_e\mu$ for
diploid, where $N_e$ is the **effective population size**.

:::

::: {.fragment}

The **mutation - drift balance** is when the diversity lost due to drift
equals the diversity gained due to mutation.

:::

:::

::: {.column width="40%"}

::: {.fragment}

```{r }
#| label: fig-wf-mutation
#| echo: false
#| eval: true
#| fig-height: 15
#| fig-width: 12
#| out-height: 500px
#| out-width: 400px
#| fig-align: center
#| fig-cap: |
#|   Variation is introduced by mutations (black) at rate $\mu=1e^{-4}$
#|   and is  occasionally lost through genetic drift.
set.seed(1212)
wf <- wright_fisher_pop(n = 40, generations = 30, mu = 0.0001)
ggplot_wf(wf, fill = allele) +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

:::

::::

::: {.notes }

Segue: so if drift removes variation, what introduces it? Mutation!

Note that the mutation rate in the WF model is not meaningful; the
value is simply chosen such that enough mutations show up in plot.

:::

## Tracing the evolution of mutations

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-tracing-evolution-of-mutations
#| echo: false
#| eval: true
#| fig-height: 15
#| fig-width: 15
#| out-width: 80%
#| fig-align: center
#| fig-cap: |
#|   Different mutations suffer different fates.
#|   Most mutations are lost in a couple of
#|   generations. Mutant alleles are colored
#|   black and their genealogies are highlighted
#|   with thicker edges.
j <- wf %E>%
  filter(.N()$allele[from] == "a" & .N()$allele[to] == "A") %>%
  pull(., to)
V(wf)$m0 <- V(wf)$allele
cliques <- ego(wf,
  order = attr(wf, "generations"),
  nodes = j, mode = "out"
)
wf %>%
  mutate(clique = .N()$m0 != "a") %E>%
  mutate(width = (0.2 + as.integer(.N()$allele[from] != "a"))) %N>%
  ggplot_wf(fill = clique, node_color = "lightgray")
```

:::

::: {.column width="50%"}

::: {.fragment}

Observation: most mutations are in fact lost

:::

::: {.fragment}

Recall: fixation probability $\pi(p)=p$

:::

:::

::::

::: {.notes }

Difference to previous figure: here we highlight the genealogies

:::

## Mutation drift balance

Drift removes variation. Mutation reintroduces it. At equilibrium the
change in variation by definition is 0. In terms of $\mathcal{H}_t$
(the probability that two alleles are *not* identical by state),
$\Delta\mathcal{H}=0$.

One can show^[see [@gillespie_PopulationGeneticsConcise_2004, p.29 --
31] for a concise treatement] the classical formula that the
equilibrium **heterozygosity** value is

$$
\hat{\mathcal{H}} = \frac{4N_e\mu}{1 + 4N_e\mu}
$$

::: {.fragment}

$\mu$ is often assumed known, and heterozygosity is easily calculated
from data, which provides a way of estimating $N_e$.

:::

::: {.fragment}

The compound parameter $4N_e\mu$ is called the **population scaled
mutation rate** and is commonly named $\theta$ such that

$$
\hat{\mathcal{H}} = \frac{\theta}{1 + \theta}
$$

:::

::: {.notes}

@gillespie_PopulationGeneticsConcise_2004, pp. 30--31 uses a
*difference equation* approach to derive $\mathcal{H}$. Briefly, he
studies the time evolution of $\mathcal{G}$, the probability that two
alleles drawn at random without replacement from the population are
identical by state. Mutations are assumed unique, i.e., the
*infinite-alleles* model. It holds

$$
\mathcal{G}^\prime = (1-\mu)^2\left[ \frac{1}{2N} +
\left( 1 - \frac{1}{2N} \right) \mathcal{G} \right]
$$

where $(1-\mu)^2$ is the probability that no mutation occur in either
of the two sampled alleles. Since $\mu$ is small, $(1-\mu)^2 \approx
1-2\mu$, which after some manipulation gives the desired expression
for $\mathcal{H} = 1 - \mathcal{G}$.

On pages 46--47, he shows that the expression for \mathcal{H} can be
derived in a much simpler fashion using coalescent theory. Tracing two
lineages backwards in time, the probability of coalescence is 1/2N,
whereas the probability of a mutation is $1-(1-\mu)^2\approx 2\mu$;
$\mathcal{H}$ is then simply the relative probability of the two
events

$$
\mathcal{H} = \frac{2\mu}{2\mu + 1/2N} = \frac{4N\mu}{4N\mu + 1}
$$

:::

## The neutral theory of evolution

:::: {.columns}

::: {.column width="50%"}

Mutation drift balance, together with the observation during 50's-60's
that polymorphism was more common than expected, is the foundation of
the **neutral theory** of evolution [@kimura_1983]: allele frequencies
may change and fix due to chance alone and not selection; most
mutations behave as if they are **neutral**.

::: {.fragment}

**Nearly neutral theory** [@ohta_SlightlyDeleteriousMutant_1973] was
later developed to explain failure to predict scaling of polymorphism
with population size: most mutations are not neutral but *slightly
deleterious* and *purged* from population by natural selection.

:::

:::

::: {.column width="50%"}

```{r }
#| label: fig-heterozygosity-function-ne
#| echo: false
#| eval: true
#| out-width: 60%
#| fig-align: center
#| fig-cap:
#|     Heterozygosity H=\frac{\theta}{1 + \theta} predicted by
#|     the neutral theory.
#|     Shaded region shows typical heterozygosities in animals (y-axis).
#|     The observed $N_e\mu$ range is higher than predicted from plot.
#|     From @hurst_GeneticsUnderstandingSelection_2009, Fig 1.
NeMu <- c(
    seq(0.001, 0.999, 0.001),
    seq(1, 9.9, 0.1),
    seq(10, 100, 1)
)
ticks <- data.frame(x = c(trans_breaks("log10", function(x) 10^x)(c(0.001, 100)),
                          0.01483, 0.0567))
data <- data.frame(NeMu=NeMu,
                   H=4*NeMu / (1 + 4*NeMu))
ggplot(data, aes(x=NeMu, y=H)) + geom_line() +
  scale_x_continuous(trans="log10",
                     breaks = ticks$x,
                     labels = function(x) ifelse(x==0, "0", x),
                     expand = c(0, 0)) +
  scale_y_continuous(
      breaks = c(seq(0, 1, 0.1), 0.056, 0.185),
      labels = function(x) ifelse(x==0, "0", x),
      expand=c(0,0)) +
  ylab("Heterozygosity (H)") + xlab(expression(N[e]~mu)) +
  geom_rect(inherit.aes=FALSE,
            data = data.frame(xstart = c(0.01483, 0.01483), xend = c(0.0567, 0),
                              ystart = c(0, 0.056), yend = c(0.185, 0.185)),
                              aes(xmin = xstart, xmax = xend,
                                  ymin = ystart, ymax = yend,
                                  fill = "red"), alpha = 0.4,
            show.legend=FALSE)
```

:::

::::

::: {.notes }

Related to rate of substitution and molecular evolution is the work of
Kimura that lead to the development of the neutral theory.

Motivation: if polymorphic sites deleterious, should not expect much
polymorphism.

Low levels of polymorphism expected assuming little balancing
selection [@hurst_GeneticsUnderstandingSelection_2009, p. 87]; however
electrophoretic studies showed polymorphism common. Would lead to
detrimental load [@kimura_ProteinPolymorphismPhase_1971] -> therefore
majority of polymorphism must evolve neutrally (dynamics). Also: rate
of evolution (on protein level) too high (Haldane's dilemma)

On the shaded region: the observed range of $N_e\mu$ is larger than
that which is predicted by the plot, and since $\mu$ is constrained
within a couple of orders of magnitude, $N_e$ must vary more than
predicted by the (strictly) neutral theory.

Conversely: given a constrained $\mu$, we observe a range of $N_e\mu$
that predicts a heterozygosity range H, which is much larger than that
which we observe. In other words, the heterozygosity range is much
lower than predicted by the neutral, given the observed $N_e\mu$
range, so some other process must reduce variation somehow.

The general idea of nearly neutral theory is that most mutations are
slightly deleterious and therefore purged by natural selection,
thereby reducing observed variation. The efficacy of purging depends
in turn on the effective population size, such that species with small
$N_e$ will have a harder time getting rid of potentially damaging
variants.

:::

## Mutation rate can be estimated from substitution rate

Mutation enters populations and may be fixed by drift. Therefore, with
time there will be fixed differences, or **substitions** (typically in
the evolution of species) between populations, or species. In
molecular evolution, the **substition rate**, **$\rho$**, is the most
interesting quantity.

::: {.fragment}

The total number of new mutations in every generation is $2N\mu$
(total number of gametes times mutation rate)

:::

::: {.fragment}

New mutations fix at a rate $1/2N$

:::

::: {.fragment}

Therefore, the **average rate of substitution**, **$\rho$**, is $2N\mu\times1/2N$, or

$$
\rho=\mu
$$

which is independent of population size!

:::

::: {.fragment}

Practical implication: we can *estimate mutation rate from the
substitution rate* at neutrally evolving sites (e.g.,
@kumar_MutationRatesMammalian_2002)

:::

::: {.notes }

What happens when sufficient amount of time passes? Mutations **fix**
and generate **substitutions** between species. This slide presents
Kimura's remarkable result regarding mutation rate and substitution
rate!

On $2N\mu$: the larger the population, the larger the number of
mutations that can fix

If $4N\mu>>0$ no new mutations can fix. Issue here is there is no
explicit mention of DNA sequence -> introduction of infinite sites
model

For practical note on estimation of mutation rate see e.g.,
[@hubisz_InferenceAncestralRecombination_2020, p. 247]

[@kumar_MutationRatesMammalian_2002, first paragraph]:

> Rates of point mutation can be determined indirectly by estimating
> the rate at which the neutral substitutions accumulate in
> protein-coding genes

:::

# Selection

:::{}

![](assets/images/gould_finches.webp){width=500px fig-align=center}

:::

::: {.notes }

For a list of methods see <https://methodspopgen.com/methods-to-detect-selection/>

:::

## Selection and fitness {.smaller}

```{r, engine='tikz', fig.ext='svg' }
#| label: fig-selection-model-tikz
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 700px
#| fig-cap:
#|     The life cycle used in the fundamental model of selection
#|     [@gillespie_PopulationGeneticsConcise_2004, Fig. 3.2]
%%https://tex.stackexchange.com/questions/97201/how-to-anchor-labels-in-tikz-for-baseline-alignment
\begin{tikzpicture}[>=latex, ultra thick, node distance=8em,
                    inner sep=0.5ex]
\tikzstyle{freq} = [anchor=mid, text depth=0pt]
\tikzstyle{state} = [anchor=mid,
                     rectangle, draw=black, node distance=12em,
                     minimum height=4em, align=center,
                     minimum width=6em, text width=4em]
%% text depth=0pt,
\node[state] (t0) {Newborns $p$};
\node[left of=t0] (pin) {$p$};
\node[state, right of=t0] (t1) {Adults $p^\prime$};
\node[right of=t1] (pout) {$p^\prime$};
\node[draw=black, rectangle, dashed, minimum height=7em,
      minimum width=24em] (dash) at ($(t0) !.5! (t1)$) {};
\node[below of=dash, node distance=4.2em] {One generation};
\draw[->] (pin) -- (t0);
\draw[->] (t0) -- node[auto, midway] {Selection} (t1);
\draw[->] (t1) -- (pout);
\end{tikzpicture}
```

::: {.fragment}

> Much confusion exists in the literature regarding how various types
> of selection are defined, in particular because some of the
> terminology is used slightly differently within different scientific
> communities [@nielsen_MolecularSignaturesNatural_2005]

:::

:::: {.columns}

::: {.column width="50%" .fragment}

$$
\begin{matrix}
\mathrm{Genotype} & AA & Aa & aa \\
\mathrm{Frequency\ in\ newborns} & p^2 & 2pq & q^2\\
\mathrm{Viability} & w_{AA} & w_{Aa} & w_{aa}\\
\mathrm{Frequency\ after\ selection} & p^2w_{AA} / \bar{w} &
    2pqw_{Aa} / \bar{w} & q^2w_{aa} / \bar{w} \\
\mathrm{Relative\ fitness} & 1 & 1-hs & 1-s\\
\end{matrix}
$$

where $\bar{w} = p^2w_{AA} + 2pqw_{Aa} + q^2w_{aa}$ is the **mean
fitness**.

:::

::: {.column width="50%" .fragment}

|         |                                        |
|---------|----------------------------------------|
| $h=0$   | $A$ dominant, $a$ recessive            |
| $h=1$   | $a$ dominant, $A$ recessive            |
| $0<h<1$ | incomplete dominance                   |
| $h<0$   | overdominance (heterozygote advantage) |
| $h>1$   | underdominance                         |

::: {.flushright .smallr}

Notation follows @gillespie_PopulationGeneticsConcise_2004, pp. 61--64.

:::

:::

::::

::: {.notes}

The life cycle figure starts with newborns carrying the $A$ allele at
frequency $p$, like parents. To reproduce they must reach adulthood,
but due to selection, the allele frequency of $A$ may shift to
$p^\prime$ because different genotypes affect survival probabilities.
This is typically summarized in genotype *viabilities*.

The Nielsen quote is a reminder that many different notations and
parametrizations exist in the literature.

:::

## The most important equation in population genetics

$$
p^\prime - p = \Delta_sp = \frac{pq[p(w_{AA} - w_{Aa}) + q(w_{Aa} -
w_{aa})]}{p^2w_{AA} + 2pqw_{Aa} + q^2w_{aa}}
$$

```{r }
#| label: allele-frequency-dynamics
#| echo: false
#| eval: true
dp <- function(h, s, p) {
  q <- 1 - p
  wbar <- 1 - 2 * p * q * h * s - q * q * s
  p * q * s * (p * h + q * (1 - h)) / wbar
}
pevol <- function(p0, n, h, s) {
  p <- vector(length=n, mode="numeric")
  p[1] <- p0
  for (i in 2:n)
    p[i] <- p[i-1] + dp(h, s, p[i-1])
  p
}
p <- seq(0, 1, 0.01)
data <- as.data.frame(rbind(
    data.frame(dp=dp(0.5, 0.1, p), h=0.5, p, selection="directional"),
    data.frame(dp=dp(-0.5, 0.1, p), h=-0.5, p, selection="balancing"),
    data.frame(dp=dp(1.5, 0.1, p), h=1.5, p, selection="disruptive")
))
data$selection <- factor(data$selection,
                         levels=c("directional", "balancing",
                                  "disruptive"))
data2 <- as.data.frame(rbind(
    data.frame(p=pevol(0.1, 100, 0.5, 0.1), generation=1:100, h=0.5,
               selection="directional", p0=0.1),
    data.frame(p=pevol(0.1, 100, -0.5, 0.1), generation=1:100, h=-0.5,
               selection="balancing", p0=0.1),
    data.frame(p=pevol(0.9, 100, -0.5, 0.1), generation=1:100, h=-0.5,
               selection="balancing", p0=0.9),
    data.frame(p=pevol(0.24, 100, 1.5, 0.1), generation=1:100, h=-0.5,
               selection="disruptive", p0=0.24),
    data.frame(p=pevol(0.26, 100, 1.5, 0.1), generation=1:100, h=1.5,
               selection="disruptive", p0=0.26)
))
data2$selection <- factor(data2$selection,
                          levels=c("directional", "balancing",
                                   "disruptive"))
data2$p0 <- as.factor(data2$p0)
selnames <- list(
    `directional` = "directional (h=0.5, s=0.1)",
    `balancing` = "balancing (h=-0.5, s=0.1)",
    `disruptive` = "disruptive (h=1.5, s=0.1)"
)
selection_labeller <- function(variable, value) {
  selnames[value]
}
```

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: fig-selection-fig-p
#| echo: false
#| eval: true
#| out-height: "400"
#| out-width: "400"
#| fig-height: 8
#| fig-width: 8
#| fig-align: center
#| fig-cap:
#|    Allele frequency change over time for directional,
#|    balancing, and disruptive selection, for different
#|    values of $p_0$.
ggplot(data2, aes(x=generation, y=p, linetype=p0)) + geom_line(linewidth=1.2) +
  facet_grid(selection ~ ., labeller=selection_labeller)
```

:::

::: {.column width="50%"}

```{r }
#| label: fig-selection-fig-dp
#| echo: false
#| eval: true
#| out-height: "400"
#| out-width: "400"
#| fig-height: 8
#| fig-width: 8
#| fig-align: center
#| fig-cap: |
#|    Rate of allele frequency change as a function of
#|    allele frequency for directional,
#|    balancing, and disruptive selection.
ggplot(data, aes(x = p, y = dp)) +
  geom_line(linewidth=1.2) +
  facet_grid(selection ~ ., labeller=selection_labeller) +
  geom_hline(yintercept=0, linetype="twodash")
```

:::

::::

::: {.notes}

Given the genotype fitnesses/viabilities, we can work out the
difference in allele frequency $p-p^\prime$ between successive
generations as a function of viabilities (or relative fitnesses).
Equation relates allele frequency change to viabilities for different
genotypes. It is instructive to study the equation and plot
trajectories to gain an intuition for how allele frequencies evolve
given the different selection regimes.

The left panel shows that the three modes of selection have different
equilibrium points: for directional selection the favored homozygote
will eventually attain 100%, balancing selection has a stable
equilibrium point (attractor) for a given allelic ratio (here 25:75),
and disruptive selection has an *unstable* equilibrium point
(repeller) for a given allelic ratio.

The right panel shows the rate of *change* as a function of allele
frequency. Note how the directionality changes at the equilibrium
point for balancing and directional selection.

:::

## Selection and drift - population size matters

:::: {.columns}

::: {.column width="80%"}

```{r }
#| label: fig-selection-and-drift
#| echo: false
#| eval: true
#| fig-width: 12
#| fig-height: 6
#| fig-cap:
#|     The fixation probability relative to the neutral
#|     probability of fixation ($p=1/2N$) under the assumption $s<0.1$.
#|     Red highlights region where $|N_es|<0.05$.
#|     Adapted from @lynch_OriginsGenomeArchitecture_2007, Fig. 4.2.
Ne_s <- seq(-2, 2, 0.01)
# Lynch p. 74
thetaf <- 4*Ne_s / (1-exp(-4*Ne_s))
data <- as.data.frame(cbind(Ne_s, thetaf))
ggplot(data, aes(x=Ne_s, y=thetaf)) + geom_line() +
  ylab(expression("Relative fixation probability" ~ theta[f])) +
  xlab(expression(N[e]* s)) + geom_hline(yintercept=1, linetype="dashed") +
  geom_rect(inherit.aes=FALSE, data = data.frame(xstart=c(-0.05), xend=c(0.05)),
            aes(xmin = xstart, xmax = xend, ymin = -Inf,
                ymax = Inf, fill = "red"), alpha = 0.4,
            show.legend=FALSE)
```

:::

::: {.column width="20%"}

In red region ($|N_es|<0.05$) the probability of fixation is within
10% of neutral fixation.

**Consequence**: for any population size there exists range of
selection coefficients where mutant alleles $\approx$ neutral (**effective neutrality**).

:::

::::

::: {.notes }

Segue: note on the strength of s and the relation to $N_e$. For small
$N_e$ the relation will hold for higher $s$, meaning small populations
will have difficulties purging deleterious mutations.

Even if a new mutation has, say, $s=0.01$, it still needs to overcome
effects of drift. Only has 2% change of fixation.

In figure, we assume $s<0.1$, which is almost always the case
[@lynch_OriginsGenomeArchitecture_2007, p.74].

[@hahn_MolecularPopulationGenetics_2019, p. 133]

:::

## Direct selection can be inferred from protein substitutions {.smaller}

:::: {.columns}

::: {.column width="50%"}

For genes, the ratio of nonsynonymous to synonymous substitutions can
tell us about protein evolution:

:::: {.columns}

::: {.column width="50%"}

```
Synonymous substitution

Protein          L
DNA         --- CTT ---
                  *
DNA         --- CTC ---
Protein          L
```

:::

::: {.column width="50%"}

```
Nonsynonymous substitution

Protein          L
DNA         --- CTT ---
                 *
DNA         --- CHT ---
Protein          H
```

:::

::::

:::{}

**$\mathbf{d_N/d_S << 1}$**
: negative (purifying) selection

**$\mathbf{d_N/d_S < 1}$**
: majority nonsynonymous deleterious, some advantageous

**$\mathbf{d_N/d_S = 1}$**
: neutral or mix neutral / advantageous / deleterious mutations

**$\mathbf{d_N/d_S > 1}$**
: positive selection

:::

:::

::: {.column width="50%"}

```{r }
#| label: fig-ensembl-hsapiens-rat-dnds
#| echo: false
#| eval: true
#| out-height: "400"
#| fig-width: 8
#| fig-height: 6
#| fig-cap: |
#|     $d_n/d_s$ comparisons for human-rat orthologs. For
#|     most genes, $d_n/d_s << 1$ indicating purifying selection. A handful
#|     of genes (n=9) have $d_n/d_s > 1.0$ which could indicate
#|     positive selection.
#|     [{{< fa rectangle-list >}}](
#|     {{< var recipes.base >}}#sec-recipe-slides-dn-ds-ratio-human-rat)
#| file: ../../recipes/slides/foundations/hsapiens-rat-dnds.R
```

:::

::::

::: {.fragment}

:::{.translatey50}

Not all mutations fall in genes. Methods for detecting direct
selection not applicable to studying selection on *single* mutation,
or e.g., balancing. This requires looking for specific patterns of
diversity surrounding locus under selection.

:::

:::

::: {.notes }

Segue: how do we detect selection?

Early approach: look at protein-coding sequence where nucleotide
substitutions can change the amino acid (non-synonymous, and
presumably non-neutral) or be silent (synonymous, assumed neutral).

Not all mutations in genes. Also want to look at single advantageous
mutations, or balanced polymorphisms. Must therefore look at tell-tale
signs of linked neutral variants.

:::

## Linked selection reduces diversity at neighbour loci

```{r, engine='tikz', fig.ext='svg' }
#| label: fig-selective-sweep
#| echo: false
#| eval: true
#| out-height: "300"
#| fig-cap: A selective sweep of an advantageous mutation (gray dot).
#|    Adapted from @charlesworth_ElementsEvolutionaryGenetics_2010, Fig. 8.13
\begin{tikzpicture}
  \tikzstyle{mut} = [circle, minimum height=0.4cm, fill=gray, draw];
  \tikzstyle{neutral} = [circle, minimum height=0.4cm, draw, fill=white];
  \begin{scope}
    \draw (0,0) -- (10,0);
    \node[neutral] at (3, 0) {};
    \node[neutral] at (7, 0) {};
    \draw (0,1) -- (10,1);
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (2, 2) {};
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[neutral] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
    \node[neutral] at (0.5, 4) {};
    \node[neutral] at (7, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \node[neutral] at (5, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (1, 7) {};
    \node[neutral] at (5, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (5, 8) {};
    \node[neutral] at (9, 8) {};
    \draw (0,9) -- (10,9);
    \node[neutral] at (2, 9) {};
  \end{scope}

  \draw[->, ultra thick] (11, 5) -- (19, 5);
  \node[font=\bfseries] at (15, 5.5) {\LARGE Many generations};

  \begin{scope}[shift={(20, 0)}]
    \draw (0,0) -- (10,0);
    \node[neutral] at (9, 0) {};
    \node[mut] at (3, 0) {};

    \draw (0,1) -- (10,1);
    \node[neutral] at (9, 1) {};
    \node[mut] at (3, 1) {};

    \draw (0,2) -- (10,2);
\node[neutral] at (9, 2) {};
    \node[mut] at (3, 2) {};

    \draw (0,3) -- (10,3);
    \node[neutral] at (9, 3) {};
    \node[mut] at (3, 3) {};

    \draw (0,4) -- (10,4);
    \node[neutral] at (9, 4) {};
    \node[mut] at (3, 4) {};

    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};

    \draw (0,6) -- (10,6);
    \node[neutral] at (9, 6) {};
    \node[mut] at (3, 6) {};

    \draw (0,7) -- (10,7);
    \node[neutral] at (9, 7) {};
    \node[mut] at (3, 7) {};

    \draw (0,8) -- (10,8);
    \node[neutral] at (9, 8) {};
    \node[mut] at (3, 8) {};

    \draw (0,9) -- (10,9);
    \node[neutral] at (9, 9) {};
    \node[mut] at (3, 9) {};

  \end{scope}
\end{tikzpicture}
```

Example of a selective sweep. If a sweep completes at a locus, it will
become monomorphic, as will the *neighbouring* sites. Mutation could
reintroduce variation. Recombination could increase diversity in
neighbourhood, but in a manner that depends on the *distance* from the
locus under selection.

::: {.notes }

Alternatives to direct selection tests are those that look at linked
selection. In essence, we look for characteristic patterns in the
vicinity of a selected locus. A sweep leads to the selected site and
neigbouring sites being monomorphic (and therefore invisible to tests
based on direct selection). Without recombination, mutation could
reintroduce variation. In the presence of recombination, the effect of
reduced diversity will be dependent on distance from the locus under
selection.

Note here that every sequence can be treated as an allele, such that
we in essence are looking multi- and not a bi-allelic locus.

:::

## Recombination breaks association between loci {.smaller}

:::: {.columns}

::: {.column width="60%"}

<!-- markdownlint-disable MD013 -->

![](assets/images/meiosis.webp){width=80% fig-align=center}

<!-- markdownlint-enable MD013 -->

::: {.flushright .smallr .translatey50}

@miller_HumanBiology_2020, Fig. 5.12.3

:::

Once per chromosome! But: rates vary between loci (hotspots), sex
chromosomes vs autosomes, and in some species, recombination only
occurs in one sex (e.g., *D.melanogaster*).

:::

::: {.column width="40%"}

::: {.fragment}

Main effect: association between loci breaks up.

```{r, engine="tikz", fig.ext="svg" }
#| label: recombinant-chromosomes
#| echo: false
#| eval: true
#| out-width: 60%
#| fig-align: center
\begin{tikzpicture}[>=latex, thick, anchor=mid]
\tikzset{
  pics/chrom/.default={A}{B}{below},
  pics/chrom/.style={
    font=\bfseries\Huge,
  },
  pics/chrom/.style n args = {3}{
    code = {
      \draw[rounded corners=1pt] (0, -.05) rectangle (2, .05);
      \draw (.4, -0.1) -- (.4, 0.1);
      \draw (1.6, -0.1) -- (1.6, 0.1);
      \node (_east) at (2, 0) {};
      \node (_west) at (0, 0) {};
      \node (_mid) at (1, 0) {};
      \ifnum\pdfstrcmp{#3}{below}=0
      \node (_a) at (.4, -0.3) {#1};
        \node (_b) at (1.6, -0.3) {#2};
\fi
      \ifnum\pdfstrcmp{#3}{above}=0
      \node (_a) at (.4, 0.3) {#1};
        \node (_b) at (1.6, 0.3) {#2};
          \fi
    },
  },
}

\pic (p1) at (0, 0) {chrom={A}{B}{above}};
\pic (p2) at (0, -.3) {chrom={a}{b}{below}};

\pic (o1) at (0, -2) {chrom={A}{B}{below}};
\pic (o2) at (0, -2.8) {chrom={a}{b}{below}};
\pic (o3) at (0, -3.6) {chrom={A}{b}{below}};
\pic (o4) at (0, -4.4) {chrom={a}{B}{below}};

\node[above of=o1_mid, node distance=3ex] (g) {Gametes};
\node[right of=o1_east] (f1) {$p_{AB}$};
\node at (g.mid -| f1) {Frequencies};
\node[right of=o2_east] (f2) {$p_{ab}$};
\node[right of=o3_east] (f3) {$p_{Ab}$};
\node[right of=o4_east] (f4) {$p_{aB}$};

\draw (p1_a) -- (p2_b);
\draw (p1_b) -- (p2_a);

\node[above of=p1_west, node distance=5ex] (r) {};
\node[above of=p1_mid, node distance=5ex] (rmid) {r};
\draw[<-] (r -| p1_a) -- (rmid);
\draw[->] (rmid) -- (r -| p1_b);

\end{tikzpicture}
```

:::

:::

::::

::: {.notes}

The mechanism that breaks up association between loci is
recombination. Cartoon to right shows the possible (haploid) outcomes
of meiosis. $r$ (the recombination rate) denotes the probability that
there is a recombination event between the two loci.

The farther apart two loci on the same chromosome, the larger the
probability that a recombination event occurs between them. Note that
this can be applied to loci on different chromosomes as well; they
segregate independently.

:::

## Linkage disequilibrium and its decay

:::: {.columns}

::: {.column width="50%"}

Association between loci can be written as:

$$
D_{AB} = p_{AB} - p_Ap_B
$$

Similar expressions hold for other pairs; only need to know one
$D_{ij}$ (e.g., $D_{AB}$) so drop subscript and rewrite:

$$
p_{AB}= p_Ap_B + D
$$

If $D\neq0$ the loci are in **linkage disequilibrium**.

::: {.fragment}

Can show that decay over time is

$$
D_t = (1-r)^tD_0
$$

Recombination *decreases* D (linkage)

:::

:::

::: {.column width="50%" .fragment}

![LD between pairs of autosomal SNPs for human and mouse. From [@laurie_LinkageDisequilibriumWild_2007, Fig. 2]](assets/images/ld_mice.png)

:::

::::

::: {.notes}

Handwavy introduction of LD as quantity. There are other equations,
but the main point here is to point out that D measures the degree of
linkage (disequilibrium); the higher D, the stronger linkage is.

The figure shows the difference in LD decay among wild populations
compared to inbred mouse strains, where LD extends over several
megabases. Therefore, LD decay informs about demographic history, and
as we will see, evolutionary processes (sweeps -> longer LD blocks).

:::

## The effect of a selective sweep on diversity

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: pgip-slim-sweep-command
#| echo: true
#| eval: false
#| code-fold: true
pgip-slim --seed 42 -n 1000 -r 1e-6 -m 1e-7 --threads 12 recipes/slim/selective_sweep.slim -l 1000000 --outdir results/slim
pgip-tsstat results/slim/slim*.trees -n 10 --seed 31 -s pi -s S -s TajD -w 500 --threads 10 | gzip -v - > results/slim/selective_sweep.w500.csv.gz
```

```{r }
#| label: pgip-load-slim-data
#| echo: false
#| eval: true
data <- tidyr::tibble(read.csv("../../pgip_data/results/slim/selective_sweep.w500.csv.gz", header = TRUE))
a <- sum(1 / seq(10 - 1))
data$thetaW <- data$S / a
data_mean <- as.data.frame(data) %>%
  select(windows, TajD, pi, S, thetaW) %>%
  group_by(windows) %>%
  summarise(TajD = mean(TajD, na.rm = TRUE), pi = mean(pi, na.rm = TRUE), S = mean(S, na.rm = TRUE), thetaW = mean(thetaW, na.rm = TRUE)) %>%
  mutate(fn = "mean", pi_minus_thetaW = pi - thetaW)
L <- 1e6
xi <- L / 2
```

<!-- markdownlint-enable MD013 -->

<!-- markdownlint-disable MD013 -->

```{r }
#| label: fig-pgip-slim-sweep-plot-tajd
#| echo: false
#| eval: true
#| fig-align: center
#| fig-height: 5
#| fig-width: 10
#| out-width: 80%
#| fig-format: png
#| fig-cap: The effect of a selective sweep on
#|     diversity. The arrow points to the site under selection.
#|     The y-axis shows Tajima's D which is proportional to the
#|     difference between two measures of diversity, nucleotide
#|     diversity $\pi$ and Watterson's $\theta_W$.
#|     [{{< fa rectangle-list >}}]({{< var recipes.slim
#|     >}}#sec-recipe-slim-selective-sweep)
x <- subset(data, fn %in% levels(factor(data$fn))[1:50])
psweep_static <- ggplot(x, aes(windows, TajD, group = fn)) +
  geom_line(color = "lightgray", linewidth = 0.5) +
  xlab("Chromosomal position") +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  geom_segment(aes(x = xi, y = -2, xend = xi, yend = -2.5), arrow = arrow(length = unit(0.4, "cm"), type = "closed")) +
  scale_y_continuous(expand = c(0, 0), limits = c(-2.5, 2.5)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, L))
p <- psweep_static + transition_manual(fn, cumulative = TRUE)
p
```

<!-- markdownlint-enable MD013 -->

::: {.notes }

Simulation: N=1e4, mu=5e-8, pi=4*N*mu=0.004, seek S=a*pi=0.01, so
a=S/pi which gives n. One needs to ramp up recombination rate to see
the dip in TajD clearly.

:::

## The effect of a selective sweep on diversity

<!-- markdownlint-disable MD013 -->

```{bash }
#| label: pgip-slim-sweep-command-2
#| echo: true
#| eval: false
#| code-fold: true
pgip-slim --seed 42 -n 1000 -r 1e-6 -m 1e-7 --threads 12 recipes/slim/selective_sweep.slim -l 1000000 --outdir results/slim
pgip-tsstat results/slim/slim*.trees -n 10 --seed 31 -s pi -s S -s TajD -w 500 --threads 10 | gzip -v - > results/slim/selective_sweep.w500.csv.gz
```

<!-- markdownlint-enable MD013 -->

```{r}
#| label: fig-pgip-slim-sweep-plot-tajd-2
#| echo: false
#| eval: true
#| fig-align: center
#| fig-height: 5
#| fig-width: 10
#| out-width: 80%
#| fig-cap: The effect of a selective sweep on
#|     diversity. The arrow points to the site under selection.
#|     The y-axis shows Tajima's D which is proportional to the
#|     difference between two measures of diversity, nucleotide
#|     diversity $\pi$ and Watterson's $\theta_W$.
#|     [{{< fa rectangle-list >}}]({{< var recipes.slim
#|     >}}#sec-recipe-slim-selective-sweep)
psweep_static + geom_line(data = data_mean, color = "red", linewidth = 1.5)
```

::: {.notes}

Important: individual runs show a lot of stochasticity, but the
signal is clear for the *mean*.

:::

## The effect of a selective sweep on diversity

```{r }
#| label: pgip-load-slim-data2
#| echo: false
#| eval: true
data <- tidyr::tibble(read.csv("../../pgip_data/results/slim/selective_sweep.w500.csv.gz",
                               header = TRUE))
a <- sum(1 / seq(10 - 1))
data$thetaW <- data$S / a
data_mean <- as.data.frame(data) %>%
  dplyr::select(windows, TajD, pi, S, thetaW) %>%
  group_by(windows) %>%
  summarise(TajD = mean(TajD, na.rm = TRUE),
            pi = mean(pi, na.rm = TRUE), S = mean(S, na.rm = TRUE),
            thetaW = mean(thetaW, na.rm = TRUE)) %>%
  mutate(fn = "mean", pi_minus_thetaW = pi - thetaW)
L <- 1e6
xi <- L / 2
```

```{r }
#| label: fig-pgip-slim-sweep-plot-pi-S
#| echo: false
#| eval: true
#| fig-align: center
#| fig-height: 5
#| fig-width: 10
#| out-width: "600"
#| fig-cap:
#|     The effect of a selective sweep on diversity.
#|     The figure shows the mean of 1000 simulations
#|     with the selected locus indicated with an arrow.
x <- data_mean %>% pivot_longer(
  cols = c("pi", "thetaW", "pi_minus_thetaW"),
  names_transform =
    list(name = ~readr::parse_factor(.x, levels = c("pi", "thetaW",
                                                    "pi_minus_thetaW")))
  )
ggplot(x, aes(windows, value, color = name)) +
  geom_segment(aes(x = xi, y = -1, xend = xi, yend = -2.5),
               color = "black", arrow = arrow(length = unit(0.4, "cm"),
                                              type = "closed")) +
  xlab("Chromosomal position") +
  ylab("diversity") +
  geom_line(linewidth = 1) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
        legend.title = element_blank()) +
  scale_y_continuous(expand = c(0, 0), limits = c(-2.5, 10)) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, L)) +
  scale_colour_manual(
    name = "name", values = c("blue", "red", "green"),
    labels = expression("diversity "~pi, theta[W], pi - theta[W])
  )
```

::: {.notes}

cf @nielsen_MolecularSignaturesNatural_2005. Not clear how scaling of
statistics to have mean=1 is done.

:::

## Distinguishing selection from drift via topology {visibility="hidden" .unnumbered .unlisted}

:::: {.columns}

::: {.column width="50%"}

```{r }
#| label: wf-model-drift-genealogy
#| echo: false
#| eval: true
#| out-height: "600"
set.seed(181)
ngen <- 50
n <- 30
wf <- wright_fisher_pop(n = 30, generations = 50, p0=1, init_gen=5)
samples <- sort(sample(which(V(wf)$y == (ngen - 1)), 10))
obj <- wf
i <- V(obj)[unlist(ego(obj, order = ngen - 7, nodes = samples, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele),
                  color = "black", shape = 21, size = 1.5) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.1, 1)) +
  scale_fill_manual(values = c("a" = "white", "A" = "black")) +
  ggtitle("drift")
```

:::

::: {.column width="50%"}

```{r }
#| label: wf-model-selection-genealogy
#| echo: false
#| eval: true
#| out-height: "600"
set.seed(1232)
ngen <- 50
n <- 30
wf <- wright_fisher_pop(n = n, generations = ngen, p0=1, init_gen=5, s=.2)
#samples <- sort(sample(which(V(wf)$y == (ngen - 1)), 12))
obj <- wf
i <- V(obj)[unlist(ego(obj, order = 43, nodes = samples, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(ggplot2::aes(fill = allele),
                  color = "black", shape = 21, size = 1.5) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_fill_manual(values = c("a" = "white", "A" = "black")) +
  scale_y_reverse() + scale_edge_width(range = c(.1, 1)) +
  ggtitle("selection")
```

:::

::::

::: {.notes }

Even though the WF model assumes neutrality, we model an allele with a
slight selective advantage. Note that the topology for selection is
more compressed (=faster coalescence) than in the neutral case.

:::

## The phases of a selective sweep

:::: {.columns}

::: {.column width="70%"}

```{R, engine="tikz", fig.ext="svg" }
#| label: fig-selective-sweep-phases
#| echo: false
#| eval: true
#| out-height: "400"
#| fig-cap:
#|     Time goes from left to right. As sweep progresses,
#|     tree topology changes. Adapted from
#|     @hahn_MolecularPopulationGenetics_2019, Figure 8.1
\begin{tikzpicture}[inner sep=0, outer sep=0, thick]
\tikzstyle{neutral} = [circle, minimum height=0.4cm, draw, fill=white];
\tikzstyle{mut} = [circle, minimum height=0.4cm, fill=black, draw];
  \begin{scope}
  \path (0, 0) node (a1) {}
  (1, 0) node (a2) {}
  (2, 0) node (a3) {}
  (3, 0) node (a4) {}
  (4, 0) node (a5) {}
  (5, 0) node (a6) {};
\node (a7) at ($(a1) !.5! (a2) + (0, 1)$) {};
\node (a8) at ($(a1-|a7) !.5! (a3) + (0, 3)$) {};
\node (a9) at ($(a4) !.5! (a5) + (0, 4)$) {};
\node (a10) at ($(a1-|a9) !.5! (a6) + (0, 6)$) {};
\node (a11) at ($(a1-|a8) !.5! (a1-|a10) + (0, 10)$) {};
  \draw (a1) -- (a7)
(a2) -- (a7)
(a7) -- (a8)
(a3) -- (a8)
(a4) -- (a9)
(a5) -- (a9)
(a6) -- (a10)
(a9) -- (a10)
(a10) -- (a11)
(a8) -- (a11)
;
\node[mut] at ($(a6) !.1! (a10)$) {};
\draw (0, -2) -- (6, -2)
(0, -3) -- (6, -3)
(0, -4) -- (6, -4)
(0, -5) -- (6, -5)
(0, -6) -- (6, -6)
(0, -7) -- (6, -7)
;
\node[neutral] at (5, -2) {};
\node[mut] at (4, -3) {};
\node[neutral] at (2, -3) {};
\node[neutral] at (5, -3) {};
\node[neutral] at (2, -4) {};
\node[neutral] at (1, -5) {};
\node[neutral] at (3, -5) {};
\node[neutral] at (1, -6) {};
\node[neutral] at (5, -6) {};
\node[neutral] at (1, -7) {};

\end{scope}
  \begin{scope}[xshift=8cm]
  \path (0, 0) node (a1) {}
  (2, 0) node (a2) {}
  (4, 0) node (a3) {}
  (4.5, 0) node (a4) {}
  (5, 0) node (a5) {}
  (5.5, 0) node (a6) {};
\node (a7) at ($(a1) !.5! (a2) + (0, 3)$) {};
\node (a8) at ($(a3) !.5! (a6) + (0, 2)$) {};
\node (a9) at ($(a1-|a8) !.5! (a1-|a8) + (0, 10)$) {};
  \draw (a1) -- (a7)
(a2) -- (a7)
(a3) -- (a8)
(a4) -- (a8)
(a5) -- (a8)
(a6) -- (a8)
(a8) -- (a9)
(a7) -- (a9);
\node[mut] at ($(a8) !.1! (a9)$) {};
\draw (0, -2) -- (6, -2)
(0, -3) -- (6, -3)
(0, -4) -- (6, -4)
(0, -5) -- (6, -5)
(0, -6) -- (6, -6)
(0, -7) -- (6, -7)
;
\node[neutral] at (2, -2) {};
\node[mut] at (4, -2) {};
\node[neutral] at (5, -2) {};
\node[neutral] at (2, -3) {};
\node[mut] at (4, -3) {};
\node[neutral] at (5, -3) {};
\node[neutral] at (2, -4) {};
\node[mut] at (4, -5) {};
\node[neutral] at (5, -4) {};
\node[neutral] at (2, -5) {};
\node[mut] at (4, -4) {};
\node[neutral] at (5, -5) {};
\node[neutral] at (1, -6) {};
\node[neutral] at (5, -6) {};
\node[neutral] at (1, -7) {};
\node[neutral] at (3, -7) {};
    \end{scope}

  \begin{scope}[xshift=16cm]
  \path (1.5, 0) node (a1) {}
  (2, 0) node (a2) {}
  (2.5, 0) node (a3) {}
  (3, 0) node (a4) {}
  (3.5, 0) node (a5) {}
  (4, 0) node (a6) {};
\node (a7) at ($(a1) !.5! (a6) + (0, 1)$) {};
\node (a8) at ($(a7) + (0, 9)$) {};
  \draw (a1) -- (a7)
(a2) -- (a7)
(a3) -- (a7)
(a3) -- (a7)
(a4) -- (a7)
(a5) -- (a7)
(a6) -- (a7)
(a7) -- (a8);
\node[mut] at ($(a7) !.1! (a8)$) {};
\draw (0, -2) -- (6, -2)
(0, -3) -- (6, -3)
(0, -4) -- (6, -4)
(0, -5) -- (6, -5)
(0, -6) -- (6, -6)
(0, -7) -- (6, -7)
;
\node[neutral] at (2, -2) {};
\node[mut] at (4, -2) {};
\node[neutral] at (5, -2) {};
\node[neutral] at (2, -3) {};
\node[mut] at (4, -3) {};
\node[neutral] at (5, -3) {};
\node[neutral] at (2, -4) {};
\node[mut] at (4, -4) {};
\node[neutral] at (5, -4) {};
\node[neutral] at (2, -5) {};
\node[mut] at (4, -5) {};
\node[neutral] at (5, -5) {};
\node[neutral] at (2, -6) {};
\node[mut] at (4, -6) {};
\node[neutral] at (5, -6) {};
\node[neutral] at (2, -7) {};
\node[mut] at (4, -7) {};
\node[neutral] at (5, -7) {};

    \end{scope}

\end{tikzpicture}
```

:::

::: {.column width="30%" .fragment}

Amount of diversity depends on fixation time. A neutral locus fixes in
$4N_e$ generations; for $s=0.0001$, it takes approximately $0.29N_e$
generations.

Selections changes the genealogy (different topology, shorter
branches), an aspect used in many linkage-based tests for selection.

:::

::::

::: {.notes}

A selective sweep changes the genealogy (shorter branches, different
*topology*) compared to the neutral case, a fact that can be utilised
in linkage-based tests for selection.

Note that the amount of variation surrounding a sweep depends heavily
on the *rate* of the sweep. [@hahn_MolecularPopulationGenetics_2019,
p. 167] points out that an advantageous allele with $s=0.0001$ will
take approximately $0.29N_e$ generations to fix (compared to $4N_e$
generations for a neutral locus)

:::

## Linked selection may constrain levels of diversity

:::{}

```{r, engine='tikz', fig.ext='svg' }
#| label: fig-hitchhiking-vs-background-selection
#| echo: false
#| eval: true
#| out-width: 1000px
#| fig-cap: Hitchhiking (left) versus background selection (right).
\begin{tikzpicture}
  \tikzstyle{mut} = [circle, minimum height=0.4cm, fill=gray, draw];
  \tikzstyle{neutral} = [circle, minimum height=0.4cm, draw, fill=white];

\begin{scope}
    \draw (0,0) -- (10,0);
    \node[neutral] at (3, 0) {};
    \node[neutral] at (7, 0) {};
    \draw (0,1) -- (10,1);
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (2, 2) {};
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[neutral] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
    \node[neutral] at (0.5, 4) {};
    \node[neutral] at (7, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \node[neutral] at (5, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (1, 7) {};
    \node[neutral] at (5, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (5, 8) {};
    \node[neutral] at (9, 8) {};
    \draw (0,9) -- (10,9);
    \node[neutral] at (2, 9) {};
  \end{scope}

  \draw[->, ultra thick] (11, 5) -- (14, 5);

  \begin{scope}[shift={(15, 0)}]
    \draw (0,0) -- (10,0);
    \node[neutral] at (9, 0) {};
    \node[mut] at (3, 0) {};

    \draw (0,1) -- (10,1);
    \node[neutral] at (9, 1) {};
    \node[mut] at (3, 1) {};

    \draw (0,2) -- (10,2);
\node[neutral] at (9, 2) {};
    \node[mut] at (3, 2) {};

    \draw (0,3) -- (10,3);
    \node[neutral] at (9, 3) {};
    \node[mut] at (3, 3) {};

    \draw (0,4) -- (10,4);
    \node[neutral] at (9, 4) {};
    \node[mut] at (3, 4) {};

    \draw (0,5) -- (10,5);
    \node[neutral] at (9, 5) {};
    \node[mut] at (3, 5) {};

    \draw (0,6) -- (10,6);
    \node[neutral] at (9, 6) {};
    \node[mut] at (3, 6) {};

    \draw (0,7) -- (10,7);
    \node[neutral] at (9, 7) {};
    \node[mut] at (3, 7) {};

    \draw (0,8) -- (10,8);
    \node[neutral] at (9, 8) {};
    \node[mut] at (3, 8) {};

    \draw (0,9) -- (10,9);
    \node[neutral] at (9, 9) {};
    \node[mut] at (3, 9) {};

\end{scope}

  \begin{scope}[shift={(35, 0)}]
    \draw (0,0) -- (10, 0);
    \node[neutral] at (3, 0) {};
\node[neutral] at (7, 0) {};
    \node[mut] at (9, 0) {};
\draw (0,1) -- (10,1);
    \node[neutral] at (7, 1) {};
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[mut] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
\node[neutral] at (0.5, 4) {};
\node[neutral] at (3.5, 4) {};
    \node[neutral] at (8.5, 4) {};
    \node[neutral] at (7, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (5, 5) {};
    \node[neutral] at (4, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (5, 7) {};
    \node[neutral] at (8, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (4, 8) {};
    \node[mut] at (7, 8) {};
    \draw (0,9) -- (10,9);
\node[neutral] at (2, 9) {};
\node[neutral] at (9, 9) {};
  \end{scope}

  \draw[->, ultra thick] (46, 5) -- (49, 5);

  \begin{scope}[shift={(50, 0)}]
    \draw (0,0) -- (10, 0);
    \node[neutral] at (3, 0) {};
\node[neutral] at (7, 0) {};
\draw (0,1) -- (10,1);
    \node[neutral] at (7, 1) {};
    \node[neutral] at (8, 1) {};
    \draw (0,2) -- (10,2);
    \node[neutral] at (3, 2) {};
    \node[neutral] at (4, 2) {};
    \node[neutral] at (9, 2) {};
    \draw (0,3) -- (10,3);
    \node[mut] at (3, 3) {};
    \node[neutral] at (7, 3) {};
    \draw (0,4) -- (10,4);
    \node[neutral] at (5, 4) {};
    \node[neutral] at (4, 4) {};
    \draw (0,5) -- (10,5);
    \node[neutral] at (5, 5) {};
    \node[neutral] at (4, 5) {};
    \draw (0,6) -- (10,6);
    \node[neutral] at (2, 6) {};
    \draw (0,7) -- (10,7);
    \node[neutral] at (5, 7) {};
    \node[neutral] at (8, 7) {};
    \draw (0,8) -- (10,8);
    \node[neutral] at (2, 8) {};
    \node[neutral] at (9, 8) {};
    \draw (0,9) -- (10,9);
    \node[neutral] at (2, 9) {};
    \node[neutral] at (9, 9) {};
  \end{scope}

\end{tikzpicture}
```

:::

:::: {.columns}

::: {.column width="50%"}

#### Hitchhiking

- alleles linked to locus under selection "hitchhike" to high
  frequencies [@smith_HitchhikingEffectFavourable_1974]
- evidence: positive correlation between putative neutral diversity
  and recombination [@corbett-detig_NaturalSelectionConstrains_2015]

:::

::: {.column width="50%"}

#### Background selection

- loci linked to a deleterious locus will be purged from population
  and thus reduce diversity [@charlesworth_EffectDeleteriousMutations_1993]
- similar patterns to hitchhiking

:::

::::

::: {.notes}

Linked selection has been proposed as solution to the low range of
diversity seen between species with orders of magnitude ranges in
census population sizes.

:::

## Summary

We have looked at the **Wright-Fisher model** as a model of populations and **genealogies***

**Genetic drift** moves allele frequencies up and down at random and
removes variation at rate $\propto 1/2N$

**Mutation** reintroduces variation. The **Neutral theory** posits
most mutations are neutral and dynamics follow **mutation drift**
equilibrium.

Methods to detect **selection** are based on **direct selection** or
studying patterns of variation caused by **linked selection**.

## Bibliography {.unnumbered .unlisted .smaller}

::: { #refs }
:::
