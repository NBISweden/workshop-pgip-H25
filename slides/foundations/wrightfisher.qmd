---
title: The Wright-Fisher model
subtitle: Of population models and genealogies
description: >-
  Introduction to the Wright-Fisher population model and relationship
  to genealogies
author:
  - Per Unneberg
format:
  nbis-quarto-revealjs:
    footer: Wright-Fisher model
---

## Setup {visibility="hidden" .hidden .unnumbered .unlisted}

{{< include /slides/_knitr.qmd >}}

{{< include /slides/_rlibs.qmd >}}

```{r }
#| label: custom-libs
#| echo: false
#| eval: true
library(viridisLite)
library(gganimate)
library(patchwork)
library(expm)
library(gridExtra)
library(igraph)
library(ggraph)
library(tidygraph)
```

## Models of populations

:::{}

```{r }
#| label: wright-fisher-drift-models-of-population
#| echo: false
#| eval: true
#| cache: false
#| fig-align: center
#| out-width: 30%
set.seed(1974)
g <- wright_fisher_pop(n = 8, generations = 8, p0 = 3)
ggplot_wf(g, fill = allele) +
  scale_fill_manual(values = c("a" = "white", "A" = "black"))
```

:::

::: {.notes }

Segue: take a step back to the days before the nature of genetic
inheritance was known. First focus on the population.

Goal of lecture is also to understand genetic relationships in the
context of genealogies -> coalescent.

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

::: {.incremental}

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

:::

:::

::: {.column width="50%"}

:::

::::

::: {.notes }

See @hein_GeneGenealogies_2004 for more assumptions. The second
assumption means we can use 2N chromosome interchangeably for haploid
(n=2N) and diploid (n=N) populations.

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero

:::

::: {.column width="50%"}

```{r }
#| label: wright-fisher-model-graph
#| echo: false
#| eval: true
#| cache: false
set.seed(2023)
wf <- wright_fisher_pop(n = 10, generations = 16)
```

```{r }
#| label: wf-1
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
y_range <- range(V(wf)$y)
ggplot_wf(wf %>% filter(y == 0), y_range = y_range) +
  ggtitle("Starting population")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one

:::

::: {.column width="50%"}

```{r }
#| label: wf-2
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %>%
  filter(y >= 0 & y <= 1) %E>%
  filter(from <= -1) %>%
  ggplot_wf(., y_range = y_range) + ggtitle("Offspring")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.0
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to == 11) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.1
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% c(11, 12)) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.1b
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% c(11:13)) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3.2
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:18) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:20) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  mutate(x = x[tangled]) %>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-3-untangled
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %E>%
  filter(to %in% 11:20) %N>%
  mutate(allele = ifelse(node %in% .E()$from, "parent", allele)) %>%
  mutate(allele = ifelse(node %in% .E()$to, "child", allele)) %>%
  filter(y >= 0 & y <= 1) %N>%
  ggplot_wf(., y_range = y_range, fill = allele) +
  ggtitle("Sampled parents (untangled)")
```

:::

::::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="50%"}

Model of populations that describes **genealogical** relationships of
genes (chromosomes) in a population under the following assumptions
[@hein2005gene]:

- discrete and non-overlapping generations
- haploid individuals or two subpopulations (males and females)
- constant population size
- all individuals are equally fit
- population has no geographical or social structure
- no recombination

### Algorithm

1. Setup starting population at time zero
2. Add offspring (same size) at time one
3. Select parents to offspring at random

:::

::: {.column width="50%"}

```{r }
#| label: wf-4
#| echo: false
#| eval: true
#| cache: false
#| out-width: 90%
#| fig-align: center
#| fig-height: 7
#| fig-width: 7
wf %>%
  filter(y >= 0 & y <= 2) %>%
  mutate(allele = ifelse(degree(., mode = "out") > 0 & y == 1, "b", "a")) %>%
  ggplot_wf(., y_range = y_range, fill = allele) + ggtitle("Sampled parents")
```

:::

::::

## Wright-Fisher model {.smaller}

:::{}

```{r }
#| label: fig-wright-fisher-model-latex-animate
#| echo: false
#| eval: true
#| aniopts: width=1000,controls=all
#| fig-show: animate
#| fig-keep: all
#| fig-cap: Wright-Fisher model
#| fig-format: png
#| out-width: 40%
#| fig-height: 7
#| fig-width: 7
popsize <- max(V(wf)$x) + 1
generations <- max(V(wf)$y) + 1
for (t in 3:generations) {
  obj <- wf %E>% filter(to <= (t * popsize)) %N>% filter(y >= 0 & y <= t)
  print(ggplot_wf(obj, y_range = y_range) + ggtitle(paste("Generation", t)))

  obj <- wf %N>%
    filter(y >= 0 & y <= t) %>%
    mutate(allele = ifelse(degree(., mode = "out") > 0 & y == (t - 1), "b", "a")) %E>%
    filter(to <= (t * popsize))

  print(ggplot_wf(obj, y_range = y_range, fill = allele) +
    ggtitle(paste("Generation", t)))

  obj <- wf %N>%
    filter(y >= 0 & y <= t) %>%
    mutate(allele = ifelse(degree(., mode = "out") > 0 & y == (t - 1), "b", "a")) %E>%
    filter(to <= ((t + 1) * popsize))

  print(ggplot_wf(obj, y_range = y_range, fill = allele) +
    ggtitle(paste("Generation", t)))
}
```

:::

::: {.notes }

See <https://mikeyharper.uk/animated-plots-with-r/>

:::

## Wright-Fisher model {.smaller}

:::: {.columns}

::: {.column width="33%"}

```{r }
#| label: fig-wright-fisher-model-gganimation-last
#| echo: false
#| eval: true
#| fig-cap: |
#|   WF model indicating time
#|   direction from past (top) to present
#|   (bottom).
#| out-width: 80%
#| fig-align: center
x_range <- range(vertex_attr(wf, "x"))
y_range <- range(vertex_attr(wf, "y"))
x1 <- x_range[1] - 0.5
x_range <- c(x1 - 2, x_range[2])
wf %>% ggplot_wf(.) +
  geom_segment(
    aes(
      x = x1, y = y_range[1],
      xend = x1, yend = y_range[2]
    ),
    arrow = arrow(
      length = unit(0.5, "cm"),
      type = "closed"
    )
  ) +
  annotate("text",
    label = "time",
    x = x1 - .5, y = mean(y_range),
    size = 10, angle = 90
  ) +
  annotate("text",
    label = "past",
    x = x1 - .5, y = 0,
    size = 10, hjust = 1,
  ) +
  annotate("text",
    label = "present",
    x = x1 - .5, y = 15,
    size = 10, hjust = 1,
  ) +
  expand_limits(x = x_range, y = y_range)
```

:::

:::{.column width=33% .fragment}

```{r}
#| label: fig-wf-model-genealogy-all
#| echo: false
#| eval: true
#| out-width: 80%
#| fig-align: center
#| fig-cap: "WF model tracing the genealogies of all extant chromosomes"
obj <- wf
i <- V(obj)[unlist(ego(obj, order = 16, nodes = 151:160, mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(fill = "white", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3))
```

:::

::: {.column width="33%"}

::: {.fragment}

```{r}
#| label: fig-wf-model-genealogy
#| echo: false
#| eval: true
#| out-width: 80%
#| fig-align: center
#| fig-cap: "WF model tracing the genealogies of three extant chromosomes"
obj <- wf
i <- V(obj)[unlist(ego(obj, order = 16, nodes = c(152, 155, 158), mode = "in"))]
E(obj)$color <- "lightgray"
E(obj)$width <- .1
E(obj)[.to(i)]$width <- .2
E(obj)[.to(i)]$color <- "black"
ggraph(obj, layout = cbind(V(obj)$x, V(obj)$y)) +
  geom_edge_link(aes(color = color, width = width)) +
  scale_edge_color_manual(values = c(
    "black" = "black",
    "lightgray" = "lightgray"
  )) +
  geom_node_point(fill = "white", color = "black", shape = 21, size = 3) +
  theme(legend.position = "none", axis.text.x = element_blank()) +
  scale_y_reverse() + scale_edge_width(range = c(.8, 3))
```

:::

:::

::::

:::: {.columns}

::: {.column width="70%"}

::: {.fragment}

##### Observations

- most lineages are lost over time
- looking backwards in time genes eventually **coalesce** at a common
  ancestor
- looking backwards in time sampled genes can be described by a
  **genealogy**

:::

:::

::: {.column width="30%" .fragment}

:::{.center}

```{r, engine='tikz', fig.ext="svg" }
#| label: wf-sampled-genealogy
#| echo: false
#| eval: true
#| out-height: 150px
\begin{tikzpicture}
[ultra thick, x=1cm, y=1cm, font=\Large\sffamily]
\tikzset{
  every node/.style={inner sep=0pt, outer sep=0pt},
  label/.style={inner sep=0pt, outer sep=3pt},
  mut/.style={circle, fill=red!70, minimum size=8pt},
  mlab/.style={text=red!70, node distance=8pt}
}
\def\samples{A,B,C}
\foreach \x [count=\xi] in \samples {\node[label] (\x) at (\xi,0) {};}
\def\coal{A/B/3, AB/C/7}
\foreach \left/ \right / \time [count=\xi] in \coal
{
  \node (\left\right) at ($(A -| \left) !.5! (A -| \right) + (0, \time)$) {};
  \draw (\left) |- (\left\right) -| (\right);
}
\node[above of=ABC, node distance=1cm] (root) {};
\draw (ABC) -- (root);
\end{tikzpicture}
```

:::

:::

::::

## The Wright-Fisher sampling model

Let's formalise the sampling process of the Wright-Fisher model^[For a
more extensive treatment, see
@hermisson_MathematicalPopulationGenetics_2017 or @hein2005gene]. We
assume

1. a single locus in a haploid population of size $2N$ (or diploid of
   size $N$ when random mating)
2. no mutation and selection
3. discrete generations

Each generation we sample $2N$ new chromosomes from the previous
generation. The probability of choosing a chromosome $v$ is $1/2N$
(coin flip with probability of success $1/2N$). Since the trials are
independent, and we perform $2N$ trials, the number of offspring $k$
of a given chromosome $v$ is [*binomially
distributed*](https://en.wikipedia.org/wiki/Binomial_distribution)
$\mathrm{Bin}(m, p)$, with parameters $m=2N$ and probability of
success $p=\frac{1}{2N}$.

::: {.notes}

We assume some familiarity with Binomial sampling. For reference, some
mathematical formality follows.

Let $p$ be the probability of heads (=1) of a coin flip, and $q=1-p$
the probability of tails (=0). A coin flip can be modelled by a random
variable (r.v.) $X$ that follows a *Bernoulli distribution*, where
$\mathrm{Pr(}X=1\mathrm{)}=p$, $\mathrm{Pr(}X=0\mathrm{)}=1-p=q$. One
can show (e.g., with transforms such as the [probability-generating
function](https://en.wikipedia.org/wiki/Probability-generating_function))
that a binomially distributed variable $Y\sim Bin(n, p)$ is the sum of
$n$ independent Bernoulli variables $X$ ("Bernoulli trials"), or
$Y=\sum^nX$. In our case, there are $2N$ trials, each with $p=1/2N$.

$$
P(v=k) = {2N\choose k}\left( \frac{1}{2N} \right)^k
\left(1 - \frac{1}{2N} \right)^{(2N - k)}
$$

:::

## Properties of Wright-Fisher sampling{.smaller}

:::: {.columns}

::: {.column width="50%"}

:::{.fragment}

##### The expected number of offspring is one

```{r, engine='tikz', fig.ext='svg' }
#| label: wf-expected-number-of-offspring
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 70%
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1} {
  \foreach \x in {1,2,3,4,5} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
}
\draw[->] (n13) -- (n03);
\draw[->, dotted] (n13) -- (n02);
\draw[->, dotted] (n13) -- (n04);
\node[lab, above of=n13] {$v$};
\end{tikzpicture}
```

:::

:::{.fragment}

##### Poisson approximation for large $N$

```{r, engine='tikz', fig.ext='svg' }
#| label: wf-poisson-approximation-large-n
#| echo: false
#| eval: true
#| fig-align: center
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1} {
  \foreach \x in {1,2,3,4,5,8,9,10} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {6, 6.5, 7} {\node[cdot] at (\x, \y) {};}
}
\draw[->] (n13) -- (n03);
\draw[->] (n13) -- (n02);
\draw[->] (n13) -- (n04);
\node[lab, above of=n13] {$v$};
\node[lab, above of=n11] {$1$};
\node[lab, above of=n110] {$2N$};
\end{tikzpicture}
```

$$
P(v=k) \approx \frac{1}{k!}e^{-k}
$$

:::

:::

::: {.column width="50%"}

:::{.fragment}

##### Prob(pick same parent) = 1/2N{#sec-prob-sequence-pick-same-parent}

```{r, engine="tikz", fig.ext="svg" }
#| label: wf-prob-parents-identical-fig
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: "800"
\begin{tikzpicture}
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{u} = [fill=black];
  \tikzstyle{v} = [fill=gray];
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.3cm, inner sep=0];
\foreach \y in {0, 2} {
  \foreach \x in {1,2,3,4,5,6,7,8,9,12,13,14,15} {
    \node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {10, 10.5, 11} {\node[cdot] at (\x, \y) {};}
}
\node[lab, above of=n21] {1};
\node[lab, above of=n215] {2N};
\node[lab, below of=n03] {u};
\node[lab, below of=n06] {v};
\node[lab, above of=n23] {$p_u=p_v$};
\node[lab, above of=n26] {$p_u \neq p_v$};
\node[lab, above of=n213] {$p_u \neq p_v$};
\draw[->] (n03) -- (n23);
\path[->] (n06) edge node[above right] {$\frac{1}{2N}$} (n23);
\path[->] (n06) edge[dotted] node[right] {$1-\frac{1}{2N}$} (n26);
\path[->] (n06) edge[dotted] node[above left] {$1-\frac{1}{2N}$} (n213);
\end{tikzpicture}
```

:::

:::{.fragment}

##### Time for two sequences to coalesce $\sim 1/2N$

:::: {.columns}

::: {.column width="15%"}

:::

::: {.column width="70%"}

```{r, engine="tikz", fig.ext="svg" }
#| label: wf-two-chrom-find-common-ancestor
#| echo: false
#| eval: true
#| fig-align: center
#| out-width: 100%
\begin{tikzpicture}[>=latex,thick]
  \tikzstyle{wf} = [circle, inner sep=0, minimum size=0.2cm, fill=white, draw]
  \tikzstyle{u} = [fill=black];
  \tikzstyle{v} = [fill=gray];
  \tikzstyle{neutral} = [fill=white];
\tikzstyle{cdot} = [circle, inner sep=0, minimum size=0.05cm, fill=black, draw];
\tikzstyle{lab} = [node distance=0.4cm, inner sep=0];
\foreach \y in {0,1,2,3,4,5} {
  \foreach \x in {1,2,3,4,7,8} {\node[wf, neutral] (n\y\x) at (\x, \y) {};}
  \foreach \x in {5, 5.5, 6} {\node[cdot] at (\x, \y) {};}
}
\node[lab, above of=n51] {1};
\node[lab, above of=n58] {2N};
\node[lab, below of=n02] {u};
\node[lab, below of=n04] {v};
\draw[->] (n02) -- (n11);
\draw[->] (n11) -- (n22);
\draw[->] (n22) -- (n32);
\draw[->] (n32) -- (n43);
\draw[->] (n43) -- (n53);
\draw[->] (n04) -- (n14);
\draw[->] (n14) -- (n23);
\draw[->] (n23) -- (n33);
\draw[->] (n33) -- (n44);
\draw[->] (n44) -- (n53);

\node at ($(n01) !.5! (n11) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n11) !.5! (n21) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n21) !.5! (n31) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n31) !.5! (n41) - (1, 0)$) {$1-\frac{1}{2N}$};
\node at ($(n41) !.5! (n51) - (1, 0)$) {$\frac{1}{2N}$};
\end{tikzpicture}
```

:::

::: {.column width="15%"}

:::

::::

:::

:::

::::

::: {.notes}

Many of the results above follow from standard results in probability
theory and are provided here in brevity for reference to the
interested reader. The details are not necessary to understand in
detail.

#### Expected number of offspring

The expected value of a $\mathrm{Bin}(m,p)$ (binomially distributed)
variable with parameters $m=2N$ and $p=\frac{1}{2N}$ is $mp$, hence:

$$
E(v) = mp = 2N\frac{1}{2N} = 1
$$

#### Poisson approximation

When $2N$ large it holds that the probability that sequence $v$ has
$k$ offspring is

$$
P(v=k) \approx \frac{1}{k!}e^{-k}
$$

Since $P(v=0) = e^{-1} \approx 0.37$, a fraction 0.37 of sequences lack
descendants

#### Probability that two sequences pick same parent

Let $u$ and $v$ be two sequences. Pick a parent $p_u$ of $u$. Then the
probability that $v$ picks the same parent is (solid lines)

$$
P(p_u=p_v) = \frac{1}{2N}
$$

The probability that they pick different parents is

$$
P(p_u \neq p_v) = 1 - \frac{1}{2N}
$$

##### Time for two sequences to coalescent

Time for two sequences $u$ and $v$ to find common ancestor
distributed as $(1 - \frac{1}{2N})^{j-1}\frac{1}{2N}$ ($j-1$ failures
followed by success). This is the [geometric
distribution](https://en.wikipedia.org/wiki/Geometric_distribution)
$Ge(p)$, with parameter $p=\frac{1}{2N}$, and expected value
$\frac{1}{p}={2N}$. That is, the **expected number of generations for
two sequences to find a common ancestor (i.e., coalesce) is $2N$
generations**.

Since a large fraction of genes lack descendants, very quickly
(compared to 2N) a population will descend from a small proportion of
genes.

Derivation of average time to having same parent (i.e., coalescence)
requires knowledge of geometric distribution. The probability that the
genes find common parent $j$ generations ago is

$$
(1-\frac{1}{2N})^{(j-1)}\frac{1}{2N}
$$

due to independence between generations. This is the geometric
distribution $Ge(p)$ with $p=1/2N$, which has expected value $1/p$,
i.e., 2N in this case.

:::

## Bibliography {.unnumbered .unlisted .smaller}

::: { #refs }
:::
